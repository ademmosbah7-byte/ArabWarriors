using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.Versioning;
using BepInEx;
using BepInEx.Configuration;
using DM;
using EzECS.Barriers;
using HarmonyLib;
using HiddenUnits.Properties;
using Landfall.TABC;
using Landfall.TABS;
using Landfall.TABS.AI;
using Landfall.TABS.AI.Components;
using Landfall.TABS.AI.Components.Modifiers;
using Landfall.TABS.AI.Components.Tags;
using Landfall.TABS.AI.Systems;
using Landfall.TABS.GameMode;
using Landfall.TABS.GameState;
using Landfall.TABS.UnitEditor;
using Landfall.TABS.Workshop;
using Microsoft.CodeAnalysis;
using Pathfinding;
using Photon.Bolt;
using RootMotion.FinalIK;
using TFBGames;
using TGCore;
using TGCore.Library;
using TGCore.Localization;
using Unity.Collections;
using Unity.Entities;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.SceneManagement;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = ".NET Standard 2.0")]
[assembly: AssemblyCompany("HiddenUnits")]
[assembly: AssemblyConfiguration("Release")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyInformationalVersion("1.0.0+1563b51b32be5a6d689e68d77bcf12e1462a149d")]
[assembly: AssemblyProduct("HiddenUnits")]
[assembly: AssemblyTitle("HiddenUnits")]
[assembly: AssemblyVersion("1.0.0.0")]
[module: RefSafetyRules(11)]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
	internal sealed class RefSafetyRulesAttribute : Attribute
	{
		public readonly int Version;

		public RefSafetyRulesAttribute(int P_0)
		{
			Version = P_0;
		}
	}
}
public class ClubSpell : TargetableEffect
{
	public AnimationCurve upCurve;

	public AnimationCurve forceCurve;

	public float force;

	private float RockStartY;

	private Rigidbody Rig;

	private Vector3 Direction;

	private Vector3 StartPos;

	public float prediction = 1f;

	private Rigidbody Target;

	public void Start()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		StartPos = ((Component)this).transform.position;
	}

	private IEnumerator Go()
	{
		float t3 = ((Keyframe)(ref upCurve.keys[upCurve.keys.Length - 1])).time;
		float c3 = 0f;
		while (c3 < t3)
		{
			c3 += Time.deltaTime;
			((Component)Rig).transform.localPosition = new Vector3(0f, upCurve.Evaluate(c3) + RockStartY, 0f);
			yield return null;
		}
		Rig.isKinematic = false;
		t3 = ((Keyframe)(ref forceCurve.keys[forceCurve.keys.Length - 1])).time;
		c3 = 0f;
		GetDirection(Rig.position, Target.position, Target);
		Rig.useGravity = false;
		while (c3 < t3)
		{
			c3 += Time.deltaTime;
			Rig.velocity = Direction * (forceCurve.Evaluate(c3) * force);
			yield return null;
		}
		Rig.useGravity = true;
	}

	public override void DoEffect(Transform startPoint, Transform endPoint)
	{
	}

	public override void DoEffect(Vector3 startPoint, Vector3 endPoint, Rigidbody targetRig = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Target = targetRig;
		Rig = ((Component)this).GetComponentInChildren<Rigidbody>();
		RockStartY = ((Component)Rig).transform.localPosition.y;
		((MonoBehaviour)this).StartCoroutine(Go());
	}

	public void DoSpell()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody targetMainRig = ((Component)((Component)this).transform.root).GetComponent<Unit>().data.targetMainRig;
		((TargetableEffect)this).DoEffect(StartPos, targetMainRig.position, targetMainRig);
	}

	private void GetDirection(Vector3 startPoint, Vector3 endPoint, Rigidbody targetRig)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = endPoint;
		val += targetRig.velocity * (prediction * 0.1f * Vector3.Distance(startPoint, val));
		Vector3 val2 = val - startPoint;
		Direction = ((Vector3)(ref val2)).normalized;
	}
}
public class DodgeMovePhoenix : Move, IRemotelyControllable
{
	[HideInInspector]
	public Transform targetObject;

	public float animationSpeed = 1f;

	public float animationSpeedWhenPositiveCurve = 1f;

	public float forceMultiplier = 1f;

	public bool divideForceByMass;

	public bool cancelSelf;

	public bool usedAsMovement;

	public bool randomForceMultiplier;

	public float minRange;

	public float maxRange;

	public CombatMoveDataInstance[] moves;

	[SerializeField]
	[Tooltip("See the comments in code.")]
	protected bool allowForMartian;

	private float RandomSeed;

	private DataHandler Data;

	private RigidbodyHolder AllRigs;

	private CameraAbilityPossess Possess;

	public bool IsRemotelyControlled { get; private set; }

	private void Start()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Invalid comparison between Unknown and I4
		Data = ((Component)((Component)this).transform.root).GetComponentInChildren<DataHandler>();
		AllRigs = ((Component)Data).GetComponent<RigidbodyHolder>();
		for (int i = 0; i < moves.Length; i++)
		{
			if ((int)moves[i].forceDirection == 15)
			{
				Possess = ((Component)MainCam.instance).GetComponentInParent<CameraAbilityPossess>();
			}
		}
		if (randomForceMultiplier)
		{
			RandomSeed = Random.Range(-1, 1);
			forceMultiplier = Random.Range(forceMultiplier * 0.7f, forceMultiplier);
			if (RandomSeed < 0f)
			{
				forceMultiplier = 0f - forceMultiplier;
			}
		}
	}

	public void DoMove(Transform targetObj)
	{
		targetObject = targetObj;
		DoMove();
	}

	public void DoMove()
	{
		if (!Object.op_Implicit((Object)(object)Data))
		{
			Data = ((Component)((Component)this).transform.root).GetComponentInChildren<DataHandler>();
			AllRigs = ((Component)Data).GetComponent<RigidbodyHolder>();
		}
		((Move)this).DoMove((Rigidbody)null, Data.targetMainRig, Data.targetData);
	}

	public override void DoMove(Rigidbody enemyWeapon, Rigidbody enemyTorso, DataHandler targetData)
	{
		if (cancelSelf)
		{
			((MonoBehaviour)this).StopAllCoroutines();
		}
		if (!Object.op_Implicit((Object)(object)enemyWeapon) && !Object.op_Implicit((Object)(object)enemyTorso))
		{
			return;
		}
		for (int i = 0; i < moves.Length; i++)
		{
			CombatMoveDataInstance move = moves[i];
			if (IsAllowedToDoMoveInMultiplayer(move))
			{
				((MonoBehaviour)this).StartCoroutine(DoMoveSequence(move, enemyWeapon, enemyTorso, targetData));
			}
		}
	}

	private IEnumerator DoMoveSequence(CombatMoveDataInstance move, Rigidbody enemyWeapon, Rigidbody enemyTorso, DataHandler targetData)
	{
		float t = ((Keyframe)(ref move.forceCurve.keys[move.forceCurve.keys.Length - 1])).time;
		float c = 0f;
		if (move.useAlternateForceProjectMarsClient && BoltNetwork.IsClient)
		{
			move.force = move.alternateClientForce;
		}
		move.randomMultiplier = move.randomCurve.Evaluate(Random.value);
		List<Rigidbody> rigs = new List<Rigidbody>();
		if ((int)move.rigidbodyToMove == 0)
		{
			rigs.Add(((Component)Data.head).GetComponent<Rigidbody>());
		}
		else if ((int)move.rigidbodyToMove == 1)
		{
			if (Object.op_Implicit((Object)(object)Data.torso))
			{
				rigs.Add(((Component)Data.torso).GetComponent<Rigidbody>());
			}
		}
		else if ((int)move.rigidbodyToMove == 2)
		{
			if (Object.op_Implicit((Object)(object)Data.hip))
			{
				rigs.Add(((Component)Data.hip).GetComponent<Rigidbody>());
			}
		}
		else if ((int)move.rigidbodyToMove == 3)
		{
			if (Object.op_Implicit((Object)(object)Data.footLeft))
			{
				rigs.Add(((Component)Data.footLeft).GetComponent<Rigidbody>());
			}
		}
		else if ((int)move.rigidbodyToMove == 4)
		{
			if (Object.op_Implicit((Object)(object)Data.footRight))
			{
				rigs.Add(((Component)Data.footRight).GetComponent<Rigidbody>());
			}
		}
		else if ((int)move.rigidbodyToMove == 7)
		{
			if (Object.op_Implicit((Object)(object)Data.rightHand))
			{
				rigs.Add(((Component)Data.rightHand).GetComponent<Rigidbody>());
			}
		}
		else if ((int)move.rigidbodyToMove == 6)
		{
			if (Object.op_Implicit((Object)(object)Data.leftHand))
			{
				rigs.Add(((Component)Data.leftHand).GetComponent<Rigidbody>());
			}
		}
		else if ((int)move.rigidbodyToMove == 5)
		{
			rigs.AddRange(AllRigs.AllRigs);
		}
		else if ((int)move.rigidbodyToMove == 8)
		{
			WeaponHandler weaponHandler = Data.weaponHandler;
			if (Object.op_Implicit((Object)(object)weaponHandler))
			{
				if (Object.op_Implicit((Object)(object)weaponHandler.rightWeapon) && Object.op_Implicit((Object)(object)weaponHandler.rightWeapon.rigidbody))
				{
					rigs.Add(weaponHandler.rightWeapon.rigidbody);
				}
				else if (Object.op_Implicit((Object)(object)weaponHandler.leftWeapon) && Object.op_Implicit((Object)(object)weaponHandler.leftWeapon.rigidbody))
				{
					rigs.Add(weaponHandler.leftWeapon.rigidbody);
				}
			}
		}
		else if ((int)move.rigidbodyToMove == 9)
		{
			rigs.Add(((Component)this).GetComponent<Rigidbody>());
		}
		else if ((int)move.rigidbodyToMove == 10 && Object.op_Implicit((Object)(object)move.specificRig))
		{
			rigs.Add(move.specificRig);
		}
		if (move.includeWeapons)
		{
			WeaponHandler weaponHandler2 = Data.weaponHandler;
			if (Object.op_Implicit((Object)(object)weaponHandler2))
			{
				if (Object.op_Implicit((Object)(object)weaponHandler2.leftWeapon) && Object.op_Implicit((Object)(object)weaponHandler2.leftWeapon.rigidbody))
				{
					rigs.Add(weaponHandler2.leftWeapon.rigidbody);
				}
				if (Object.op_Implicit((Object)(object)weaponHandler2.rightWeapon) && Object.op_Implicit((Object)(object)weaponHandler2.rightWeapon.rigidbody))
				{
					rigs.Add(weaponHandler2.rightWeapon.rigidbody);
				}
			}
		}
		Vector3 forceDirection = Vector3.zero;
		if (rigs.Count >= 1)
		{
			forceDirection = GetDirection(move, enemyWeapon, enemyTorso, rigs[0], targetData);
			for (int num = rigs.Count - 1; num >= 0; num--)
			{
				if ((Object)(object)rigs[num] == (Object)null)
				{
					rigs.RemoveAt(num);
				}
			}
		}
		float massM = 1f;
		if (divideForceByMass)
		{
			float num2 = 0f;
			for (int i = 0; i < rigs.Count; i++)
			{
				num2 += rigs[i].mass / (float)rigs.Count;
			}
			massM = 1f / num2;
		}
		while (c < t)
		{
			if (CheckConditions())
			{
				for (int j = 0; j < rigs.Count; j++)
				{
					if (move.setDirectionContiniouiouss)
					{
						forceDirection = GetDirection(move, enemyWeapon, enemyTorso, rigs[0], targetData);
					}
					if (!usedAsMovement || !Object.op_Implicit((Object)(object)Data) || !Object.op_Implicit((Object)(object)((Component)Data).GetComponent<AnimationHandler>()) || ((Component)Data).GetComponent<AnimationHandler>().currentState != 0)
					{
						if (move.force != 0f && Object.op_Implicit((Object)(object)rigs[j]))
						{
							rigs[j].AddForce(forceDirection * massM * move.randomMultiplier * forceMultiplier * move.force * move.forceCurve.Evaluate(c), (ForceMode)5);
						}
						if (move.torque != 0f && Object.op_Implicit((Object)(object)rigs[j]))
						{
							rigs[j].AddTorque(forceDirection * massM * forceMultiplier * move.torque * move.forceCurve.Evaluate(c), (ForceMode)5);
						}
					}
				}
			}
			float num3 = 1f;
			num3 *= animationSpeed;
			if (move.forceCurve.Evaluate(c) > 0f)
			{
				num3 *= animationSpeedWhenPositiveCurve;
			}
			c += Time.fixedDeltaTime * num3;
			yield return (object)new WaitForFixedUpdate();
		}
	}

	private bool CheckConditions()
	{
		bool result = true;
		if (maxRange != 0f && Object.op_Implicit((Object)(object)Data) && Data.distanceToTarget > maxRange)
		{
			result = false;
		}
		if (minRange != 0f && Object.op_Implicit((Object)(object)Data) && Data.distanceToTarget < minRange)
		{
			result = false;
		}
		return result;
	}

	private Vector3 GetDirection(CombatMoveDataInstance move, Rigidbody enemyWeapon, Rigidbody enemyTorso, Rigidbody ownRig, DataHandler targetData)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Invalid comparison between Unknown and I4
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Invalid comparison between Unknown and I4
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Invalid comparison between Unknown and I4
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Invalid comparison between Unknown and I4
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Invalid comparison between Unknown and I4
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Invalid comparison between Unknown and I4
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Invalid comparison between Unknown and I4
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Invalid comparison between Unknown and I4
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Invalid comparison between Unknown and I4
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		//IL_0427: Invalid comparison between Unknown and I4
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0499: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a0: Invalid comparison between Unknown and I4
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bf: Invalid comparison between Unknown and I4
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_0619: Invalid comparison between Unknown and I4
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0447: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0458: Unknown result type (might be due to invalid IL or missing references)
		//IL_045d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0465: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_0477: Unknown result type (might be due to invalid IL or missing references)
		//IL_0483: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03db: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_066c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0673: Invalid comparison between Unknown and I4
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_068c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0693: Invalid comparison between Unknown and I4
		//IL_0680: Unknown result type (might be due to invalid IL or missing references)
		//IL_0685: Unknown result type (might be due to invalid IL or missing references)
		//IL_05de: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0506: Unknown result type (might be due to invalid IL or missing references)
		//IL_0510: Unknown result type (might be due to invalid IL or missing references)
		//IL_0515: Unknown result type (might be due to invalid IL or missing references)
		//IL_051c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0521: Unknown result type (might be due to invalid IL or missing references)
		//IL_052d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0532: Unknown result type (might be due to invalid IL or missing references)
		//IL_0537: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_053f: Unknown result type (might be due to invalid IL or missing references)
		//IL_054b: Unknown result type (might be due to invalid IL or missing references)
		//IL_055c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0592: Unknown result type (might be due to invalid IL or missing references)
		//IL_0597: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_069c: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06df: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0631: Unknown result type (might be due to invalid IL or missing references)
		//IL_0638: Unknown result type (might be due to invalid IL or missing references)
		//IL_0643: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0652: Unknown result type (might be due to invalid IL or missing references)
		//IL_0606: Unknown result type (might be due to invalid IL or missing references)
		//IL_060b: Unknown result type (might be due to invalid IL or missing references)
		//IL_070a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0711: Invalid comparison between Unknown and I4
		//IL_0660: Unknown result type (might be due to invalid IL or missing references)
		//IL_0665: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_0384: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_0706: Unknown result type (might be due to invalid IL or missing references)
		//IL_0727: Unknown result type (might be due to invalid IL or missing references)
		//IL_0733: Unknown result type (might be due to invalid IL or missing references)
		//IL_0744: Unknown result type (might be due to invalid IL or missing references)
		//IL_0750: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)enemyTorso))
		{
			enemyTorso = Data.targetData.mainRig;
		}
		Vector3 val = Vector3.zero;
		if ((Object)(object)ownRig == (Object)null)
		{
			return val;
		}
		if ((int)move.forceDirection == 0)
		{
			val = Vector3.up;
		}
		if ((int)move.forceDirection == 1 && Object.op_Implicit((Object)(object)ownRig) && Object.op_Implicit((Object)(object)enemyTorso))
		{
			val = enemyTorso.position - ownRig.position;
			if (move.normalize)
			{
				val = ((Vector3)(ref val)).normalized;
			}
		}
		if ((int)move.forceDirection == 10 && Object.op_Implicit((Object)(object)ownRig) && Object.op_Implicit((Object)(object)targetData) && Object.op_Implicit((Object)(object)targetData.head))
		{
			val = targetData.head.position + ((Component)targetData.head).transform.forward * 0.1f + ((Component)targetData.head).transform.up * 0.15f - ownRig.position;
			if (move.normalize)
			{
				val = ((Vector3)(ref val)).normalized;
			}
		}
		if ((int)move.forceDirection == 2)
		{
			if (Object.op_Implicit((Object)(object)enemyWeapon))
			{
				val = ownRig.position - (enemyWeapon.worldCenterOfMass + enemyWeapon.velocity * move.predictionAmount);
				if (move.normalize)
				{
					val = ((Vector3)(ref val)).normalized;
				}
				if (move.ignoreY)
				{
					((Vector3)(ref val))..ctor(val.x, 0f, val.y);
				}
				if (Data.cantFallForSeconds < 0.5f)
				{
					Data.cantFallForSeconds = 0.5f;
				}
			}
			else if (Object.op_Implicit((Object)(object)enemyTorso))
			{
				val = -(enemyTorso.position - ownRig.position);
				if (move.normalize)
				{
					val = ((Vector3)(ref val)).normalized;
				}
			}
		}
		Vector3 val2;
		if ((int)move.forceDirection == 3)
		{
			val = Data.characterForwardObject.forward;
		}
		else if ((int)move.forceDirection == 4)
		{
			val = Data.characterForwardObject.right;
		}
		else if ((int)move.forceDirection == 5 && Object.op_Implicit((Object)(object)ownRig) && Object.op_Implicit((Object)(object)enemyTorso))
		{
			val = Vector3.Cross(Vector3.up, ownRig.position - enemyTorso.position);
			if (move.normalize)
			{
				val = ((Vector3)(ref val)).normalized;
			}
		}
		else if ((int)move.forceDirection == 6 && Object.op_Implicit((Object)(object)ownRig) && Object.op_Implicit((Object)(object)Data.targetMainRig))
		{
			val = Vector3.Cross(Vector3.up, ownRig.position - Data.targetMainRig.position);
			if (move.normalize)
			{
				val = ((Vector3)(ref val)).normalized;
			}
		}
		else if ((int)move.forceDirection == 14 && Object.op_Implicit((Object)(object)ownRig))
		{
			val = ((Component)ownRig).transform.up;
		}
		else if ((int)move.forceDirection == 15 && Object.op_Implicit((Object)(object)enemyTorso) && Object.op_Implicit((Object)(object)ownRig))
		{
			Vector3 val3;
			if (Object.op_Implicit((Object)(object)Possess) && Object.op_Implicit((Object)(object)Possess.currentUnit) && Object.op_Implicit((Object)(object)Data) && Object.op_Implicit((Object)(object)Data.unit) && (Object)(object)Possess.currentUnit == (Object)(object)Data.unit)
			{
				val2 = Vector3.Cross(((Component)MainCam.instance).transform.forward, ((Component)ownRig).transform.forward);
				val3 = -((Vector3)(ref val2)).normalized * Vector3.Angle(((Component)MainCam.instance).transform.forward, ((Component)ownRig).transform.forward);
			}
			else
			{
				val2 = Vector3.Cross(enemyTorso.position - ownRig.position, ((Component)ownRig).transform.forward);
				val3 = -((Vector3)(ref val2)).normalized * Vector3.Angle(enemyTorso.position - ownRig.position, ((Component)ownRig).transform.forward);
			}
			val = val3;
		}
		else if ((int)move.forceDirection == 7 && Object.op_Implicit((Object)(object)enemyTorso) && Object.op_Implicit((Object)(object)ownRig))
		{
			val2 = Vector3.Cross(enemyTorso.position - ownRig.position, ((Component)ownRig).transform.forward);
			val = -((Vector3)(ref val2)).normalized * Vector3.Angle(enemyTorso.position - ownRig.position, ((Component)ownRig).transform.forward);
		}
		else if ((int)move.forceDirection == 11 && Object.op_Implicit((Object)(object)targetData) && Object.op_Implicit((Object)(object)targetData.head) && Object.op_Implicit((Object)(object)ownRig))
		{
			val2 = Vector3.Cross(targetData.head.position + ((Component)targetData.head).transform.forward * 0.1f + ((Component)targetData.head).transform.up * 0.15f - ownRig.position, ((Component)ownRig).transform.forward);
			val = -((Vector3)(ref val2)).normalized * Vector3.Angle(targetData.head.position + ((Component)targetData.head).transform.forward * 0.1f + ((Component)targetData.head).transform.up * 0.15f - ownRig.position, ((Component)ownRig).transform.forward);
		}
		else if ((int)move.forceDirection == 8 && Object.op_Implicit((Object)(object)targetObject) && Object.op_Implicit((Object)(object)ownRig))
		{
			val = ((Component)ownRig).transform.position - ((Component)targetObject).transform.position;
			if (move.normalize)
			{
				val = ((Vector3)(ref val)).normalized;
			}
		}
		else if ((int)move.forceDirection == 9 && Object.op_Implicit((Object)(object)targetObject) && Object.op_Implicit((Object)(object)ownRig))
		{
			val = Vector3.Cross(Vector3.up, ownRig.position - targetObject.position);
			if (move.normalize)
			{
				val = ((Vector3)(ref val)).normalized;
			}
		}
		else if ((int)move.forceDirection == 12)
		{
			val = Data.groundedMovementDirectionObject.forward;
		}
		else if ((int)move.forceDirection == 13)
		{
			val2 = Vector3.Cross(((Component)ownRig).transform.forward, Data.groundedMovementDirectionObject.forward);
			val = ((Vector3)(ref val2)).normalized * Vector3.Angle(((Component)ownRig).transform.forward, Data.groundedMovementDirectionObject.forward);
		}
		else if (move.randomizeDirection && Random.value > 0.5f)
		{
			val *= -1f;
		}
		else if ((int)move.forceDirection == 16 && Object.op_Implicit((Object)(object)ownRig) && Object.op_Implicit((Object)(object)enemyTorso))
		{
			((Vector3)(ref val))..ctor(enemyTorso.position.x - ownRig.position.x, 0f, enemyTorso.position.z - ownRig.position.z);
		}
		return val;
	}

	public void SetIsRemotelyControlled(bool isRemotelyControlled)
	{
		IsRemotelyControlled = isRemotelyControlled;
	}

	private bool IsAllowedToDoMoveInMultiplayer(CombatMoveDataInstance move)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Invalid comparison between Unknown and I4
		if (!allowForMartian && IsRemotelyControlled)
		{
			return (int)move.rigidbodyToMove == 8;
		}
		return true;
	}
}
public class DreadSwords : MonoBehaviour
{
	public delegate void AttackedEventHandler(Rigidbody target, int useAttackID);

	public UnityEvent shootEvent;

	private ShootPosition[] SwordPoints;

	private List<SpookySword> Swords = new List<SpookySword>();

	public GameObject sourceSword;

	public float throwRange = 10f;

	public float followSpeed = 1f;

	public float throwSpeed = 100f;

	public AnimationCurve throwCurve;

	private float Counter;

	private DataHandler Data;

	private bool Done;

	public float attackRate;

	private float AttackspeedMulti = 1f;

	private int AttackID;

	public event AttackedEventHandler Attacked;

	private void Awake()
	{
		SwordPoints = ((Component)this).GetComponentsInChildren<ShootPosition>();
	}

	private void Start()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		Data = ((Component)((Component)this).transform.root).GetComponentInChildren<DataHandler>();
		List<Renderer> list = new List<Renderer>();
		for (int i = 0; i < SwordPoints.Length; i++)
		{
			SpookySword val = CreateNewSword(((Component)SwordPoints[i]).transform.position + Vector3.up * 2f, quaternion.op_Implicit(((Component)SwordPoints[i]).transform.rotation));
			Renderer[] componentsInChildren = val.gameObject.GetComponentsInChildren<Renderer>();
			if (componentsInChildren != null && componentsInChildren.Length != 0)
			{
				list.AddRange(componentsInChildren);
			}
			Swords.Add(val);
		}
		if ((Object)(object)Data != (Object)null && (Object)(object)Data.unit != (Object)null)
		{
			Data.unit.AddRenderersToShowHide(list.ToArray(), Data.unit.IsSpawnedInBlindPlacement);
		}
		for (int j = 0; j < Swords.Count; j++)
		{
			if (!((Object)(object)Swords[j].gameObject == (Object)null))
			{
				Swords[j].gameObject.transform.position = ((Component)SwordPoints[j]).transform.position;
				Swords[j].gameObject.transform.rotation = ((Component)SwordPoints[j]).transform.rotation;
			}
		}
	}

	private void Update()
	{
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		if (Done)
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)Data) && Data.Dead)
		{
			Done = true;
			for (int i = 0; i < Swords.Count; i++)
			{
				AttackID = i;
				Attack(Data.mainRig, AttackID);
			}
		}
		float num = Mathf.Clamp(Time.deltaTime, 0f, 0.02f);
		if (Object.op_Implicit((Object)(object)Data.weaponHandler))
		{
			AttackspeedMulti = Data.weaponHandler.attackSpeedMultiplier;
		}
		bool num2 = (Object)(object)Data.unit == (Object)null || !Data.unit.IsRemotelyControlled;
		Counter += Time.deltaTime * AttackspeedMulti;
		if (num2 && Object.op_Implicit((Object)(object)Data.targetMainRig) && Counter > attackRate)
		{
			float num3 = 999f;
			for (int j = 0; j < SwordPoints.Length; j++)
			{
				float num4 = Vector3.Angle(Data.targetMainRig.position - ((Component)this).transform.position, ((Component)SwordPoints[j]).gameObject.transform.position - ((Component)this).transform.position);
				if (num4 < num3 && Swords[j].sinceSpawn > 1.5f)
				{
					num3 = num4;
					AttackID = j;
				}
			}
			if (Object.op_Implicit((Object)(object)Data.targetMainRig) && Data.distanceToTarget < throwRange)
			{
				Attack(Data.targetMainRig, AttackID);
			}
		}
		for (int k = 0; k < Swords.Count; k++)
		{
			if (!((Object)(object)Swords[k].gameObject == (Object)null))
			{
				SpookySword obj = Swords[k];
				obj.sinceSpawn += num;
				Swords[k].gameObject.transform.position = ((Component)SwordPoints[k]).transform.position;
				Swords[k].gameObject.transform.rotation = ((Component)SwordPoints[k]).transform.rotation;
			}
		}
	}

	public void Attack(Rigidbody target, int useAttackID)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Counter = 0f;
		if (useAttackID < 0 || useAttackID >= Swords.Count)
		{
			useAttackID = Random.Range(0, Swords.Count);
		}
		SpookySword val = Swords[useAttackID];
		if (val != null)
		{
			((MonoBehaviour)this).StartCoroutine(DoAttack(val, target));
			shootEvent.Invoke();
			if (!Done)
			{
				Swords[useAttackID] = CreateNewSword(((Component)SwordPoints[useAttackID]).gameObject.transform.position, quaternion.op_Implicit(((Component)SwordPoints[useAttackID]).gameObject.transform.rotation));
			}
			else
			{
				val.gameObject.GetComponent<ProjectileHit>().ignoreTeamMates = false;
			}
			this.Attacked?.Invoke(target, useAttackID);
		}
	}

	private void OnDestroy()
	{
		((MonoBehaviour)this).StopAllCoroutines();
		for (int i = 0; i < Swords.Count; i++)
		{
			_ = (Object)(object)Swords[i].gameObject != (Object)null;
			Object.Destroy((Object)(object)Swords[i].gameObject);
		}
	}

	private IEnumerator DoAttack(SpookySword attackSword, Rigidbody targ)
	{
		if (!Object.op_Implicit((Object)(object)attackSword.gameObject))
		{
			yield break;
		}
		float counter3 = 0f;
		float t = ((Keyframe)(ref throwCurve.keys[throwCurve.keys.Length - 1])).time;
		ProjectileStick stick = attackSword.gameObject.GetComponent<ProjectileStick>();
		((Behaviour)attackSword.gameObject.GetComponent<RaycastTrail>()).enabled = true;
		while (counter3 < t && (!Object.op_Implicit((Object)(object)stick) || !stick.stuck))
		{
			if ((Object)(object)attackSword.gameObject == (Object)null || (Object)(object)targ == (Object)null)
			{
				yield break;
			}
			float num = Mathf.Clamp(Time.deltaTime, 0f, 0.02f);
			counter3 += Time.deltaTime;
			MoveTransform move = attackSword.move;
			Vector3 velocity = attackSword.move.velocity;
			Vector3 val = targ.position - attackSword.gameObject.transform.position;
			move.velocity = Vector3.Lerp(velocity, ((Vector3)(ref val)).normalized * throwSpeed * throwCurve.Evaluate(counter3), num * 8f);
			attackSword.gameObject.transform.rotation = Quaternion.Lerp(attackSword.gameObject.transform.rotation, quaternion.op_Implicit(quaternion.LookRotation(float3.op_Implicit(targ.position - attackSword.gameObject.transform.position), float3.op_Implicit(Vector3.up))), num * 7f);
			yield return null;
		}
		counter3 = 0f;
		while (counter3 < 0.5f && (!Object.op_Implicit((Object)(object)stick) || !stick.stuck))
		{
			float num2 = Mathf.Clamp(Time.deltaTime, 0f, 0.02f);
			counter3 += Time.deltaTime;
			if ((Object)(object)attackSword.gameObject != (Object)null)
			{
				attackSword.gameObject.transform.rotation = Quaternion.Lerp(attackSword.gameObject.transform.rotation, quaternion.op_Implicit(quaternion.LookRotation(float3.op_Implicit(attackSword.move.velocity), float3.op_Implicit(Vector3.up))), num2 * 15f);
			}
			yield return null;
		}
	}

	private SpookySword CreateNewSword(Vector3 pos, quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Expected O, but got Unknown
		SpookySword val = new SpookySword
		{
			gameObject = Object.Instantiate<GameObject>(sourceSword, pos, quaternion.op_Implicit(rot))
		};
		val.move = val.gameObject.GetComponent<MoveTransform>();
		GameObjectExtensions.FetchComponent<TeamHolder>(val.gameObject).team = Data.team;
		val.gameObject.GetComponentInChildren<CodeAnimation>().speedMultiplier = AttackspeedMulti;
		return val;
	}
}
public class HadezHands : MonoBehaviour
{
	public string swingRef;

	public string hitRef;

	private Transform TargetTrans;

	private List<AttackArm> AttackArms = new List<AttackArm>();

	public AnimationCurve reachCurve;

	public AnimationCurve goBackToHoldCurve;

	public AnimationCurve goBackToHoldCurveFollowMainRigAmount;

	public AnimationCurve throwCurve;

	private float FollowMainRigAmount;

	private Unit Unit;

	private float SnapSpeed;

	private List<Unit> HitList = new List<Unit>();

	public void Start()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Expected O, but got Unknown
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < ((Component)this).transform.childCount; i++)
		{
			AttackArm val = new AttackArm();
			val.targetObj = ((Component)((Component)this).transform.GetChild(i).Find("Target")).gameObject;
			val.restPosObj = ((Component)((Component)this).transform.GetChild(i).Find("RestPos")).gameObject;
			val.lerpSpeed = Random.Range(0.5f, 1.5f);
			val.smoothTargetPos = ((Component)this).transform.position;
			val.targetPos = ((Component)this).transform.position;
			AttackArms.Add(val);
		}
		Unit = ((Component)this).GetComponentInParent<Weapon>().connectedData.unit;
		TargetTrans = ((Component)this).transform.parent;
		((Component)this).transform.SetParent(((Component)Unit).transform);
	}

	private void Update()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TargetTrans == (Object)null || Unit.data.Dead)
		{
			Object.Destroy((Object)(object)((Component)this).gameObject);
			return;
		}
		((Component)this).transform.position = TargetTrans.position;
		((Component)this).transform.rotation = Quaternion.Lerp(((Component)this).transform.rotation, TargetTrans.rotation, Time.deltaTime * 2.5f);
		for (int i = 0; i < AttackArms.Count; i++)
		{
			AttackArm obj = AttackArms[i];
			obj.counter += Time.deltaTime;
			Vector3 val = Vector3.Lerp(AttackArms[i].smoothTargetPos, AttackArms[i].targetPos, Time.deltaTime * 10f);
			if ((int)AttackArms[i].armState == 0)
			{
				AttackArms[i].targetPos = Vector3.Lerp(AttackArms[i].targetPos, AttackArms[i].restPosObj.transform.position + GetPerlinPos(AttackArms[i].lerpSpeed) * 2f, Time.deltaTime * 3f * AttackArms[i].lerpSpeed);
				AttackArms[i].smoothTargetPos = val;
				SnapSpeed = 0f;
			}
			else
			{
				SnapSpeed += Time.deltaTime;
				AttackArms[i].smoothTargetPos = Vector3.Lerp(val, AttackArms[i].targetPos, SnapSpeed);
			}
			if (Object.op_Implicit((Object)(object)AttackArms[i].heldUnit))
			{
				AttackArms[i].targetObj.transform.position = Vector3.Lerp(AttackArms[i].smoothTargetPos, AttackArms[i].heldUnit.data.mainRig.position, FollowMainRigAmount);
			}
			else
			{
				AttackArms[i].targetObj.transform.position = AttackArms[i].smoothTargetPos;
			}
		}
		CheckAttack(AttackArms[Random.Range(0, AttackArms.Count)]);
	}

	private void CheckAttack(AttackArm attack)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Unit val = SetTarget();
		if (attack.counter > 3f && Unit.data.distanceToTarget <= 10f && (int)attack.armState == 0 && (Object)(object)val != (Object)null)
		{
			HitList.Add(val);
			attack.counter = 0f;
			((MonoBehaviour)this).StartCoroutine(Attack(attack, val));
		}
	}

	private IEnumerator Attack(AttackArm attack, Unit targetUnit)
	{
		attack.armState = (ArmState)1;
		attack.heldUnit = targetUnit;
		float c3 = 0f;
		if (swingRef != "")
		{
			ServiceLocator.GetService<SoundPlayer>().PlaySoundEffect(swingRef, 1f, ((Component)this).transform.position, (MaterialType)0, (Transform)null, 1f);
		}
		while (c3 < 3f && Object.op_Implicit((Object)(object)targetUnit) && Object.op_Implicit((Object)(object)targetUnit.data.mainRig) && !targetUnit.data.Dead)
		{
			Vector3 val = targetUnit.data.mainRig.position - attack.restPosObj.transform.position;
			attack.targetPos = attack.restPosObj.transform.position + val * reachCurve.Evaluate(c3);
			((Damagable)targetUnit.data.healthHandler).TakeDamage(100f * Time.deltaTime, Vector3.up, (Unit)null, (DamageType)0);
			c3 += Time.deltaTime * Time.timeScale;
			yield return null;
		}
		attack.armState = (ArmState)0;
		c3 = 0f;
		float t2 = AnimationCurveFunctions.GetAnimLength(goBackToHoldCurve);
		while (c3 < t2 && Object.op_Implicit((Object)(object)targetUnit) && Object.op_Implicit((Object)(object)targetUnit.data.mainRig))
		{
			Vector3 val2 = targetUnit.data.mainRig.position - attack.restPosObj.transform.position;
			attack.targetPos = attack.restPosObj.transform.position + val2 * goBackToHoldCurve.Evaluate(c3);
			c3 += Time.deltaTime;
			FollowMainRigAmount = goBackToHoldCurveFollowMainRigAmount.Evaluate(c3);
			yield return null;
		}
		HitList.Remove(attack.heldUnit);
		attack.heldUnit = null;
	}

	private Vector3 GetPerlinPos(float input)
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		input *= 0.2f;
		Vector3 result = default(Vector3);
		((Vector3)(ref result))..ctor(0f, 0f, 0f);
		result.x += Mathf.PerlinNoise(Time.time * input, 0f);
		result.y += Mathf.PerlinNoise(Time.time * input, Time.time * input);
		result.z += Mathf.PerlinNoise(0f, Time.time * input);
		result.x -= 0.5f;
		result.y -= 0.5f;
		result.z -= 0.5f;
		return result;
	}

	public Unit SetTarget()
	{
		Unit[] array = Object.FindObjectsOfType<Unit>().Cast<Unit>().Where(delegate(Unit unit)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			if (!unit.data.Dead && unit.Team != ((Component)((Component)this).transform.root).GetComponent<Unit>().Team && !HitList.Contains(unit))
			{
				Vector3 val2 = ((Component)unit.data.mainRig).transform.position - ((Component)this).transform.position;
				return ((Vector3)(ref val2)).magnitude <= 10f;
			}
			return false;
		})
			.OrderBy(delegate(Unit unit)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				Vector3 val = ((Component)unit.data.mainRig).transform.position - ((Component)this).transform.position;
				return ((Vector3)(ref val)).magnitude;
			})
			.ToArray();
		if (array.Length != 0)
		{
			return array[0];
		}
		return null;
	}
}
public class Laser : MonoBehaviour
{
	private LineRenderer Line;

	[Header("Line Settings")]
	public GameObject p1;

	public GameObject p2;

	public float maxDistance = 10f;

	[Header("Animation")]
	public float scaleMultiplier = 1f;

	[Header("Hit")]
	public UnityEvent hitEvent = new UnityEvent();

	public LayerMask layer;

	public void Awake()
	{
		Line = ((Component)this).GetComponent<LineRenderer>();
	}

	public void Activate()
	{
		((MonoBehaviour)this).StartCoroutine(Animate(activating: true));
	}

	public void Deactivate()
	{
		((MonoBehaviour)this).StartCoroutine(Animate(activating: false));
	}

	public IEnumerator Animate(bool activating)
	{
		float t = 0f;
		while (t < 1f)
		{
			t += Time.deltaTime;
			Line.widthMultiplier = Mathf.Lerp(activating ? 0f : scaleMultiplier, activating ? scaleMultiplier : 0f, Mathf.Clamp(t, 0f, 1f));
			yield return null;
		}
	}

	public void Update()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		Line.SetPosition(0, p2.transform.position);
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(p2.transform.position, p2.transform.forward, ref val, maxDistance, LayerMask.op_Implicit(layer)))
		{
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).collider))
			{
				Line.SetPosition(1, ((RaycastHit)(ref val)).point);
				p1.transform.position = ((RaycastHit)(ref val)).point;
				hitEvent.Invoke();
			}
		}
		else
		{
			Line.SetPosition(1, p2.transform.forward * maxDistance);
			p1.transform.position = p2.transform.forward * maxDistance;
		}
	}
}
public class PhoenixWings : MonoBehaviour
{
	public LayerMask mask;

	public AnimationCurve flightCurve;

	public float heightVariance = 0.5f;

	public float variationSpeed = 0.5f;

	public float flightForce;

	public float legForceMultiplier = 1f;

	private DataHandler Data;

	private RigidbodyHolder RigHolder;

	private Rigidbody RightFootRig;

	private Rigidbody LeftFootRig;

	private Rigidbody HipRig;

	private Rigidbody HeadRig;

	public float headM = 0.5f;

	private float Time;

	public bool useWings = true;

	public bool useWingsInPlacement = true;

	[Tooltip("Enable if units move erratically on the client side of ProjectMars games. Only enable if you are sure Wings.cs is causing erratic movement.")]
	public bool setUnitMainRigKinematic;

	private GameStateManager MGameStateManager;

	public float rotationTorque = 10f;

	private void Start()
	{
		Data = ((Component)((Component)this).transform.root).GetComponentInChildren<DataHandler>();
		RigHolder = ((Component)Data).GetComponent<RigidbodyHolder>();
		Data.takeFallDamage = false;
		Data.canFall = false;
		if (Object.op_Implicit((Object)(object)Data.footRight))
		{
			RightFootRig = ((Component)Data.footRight).GetComponent<Rigidbody>();
		}
		if (Object.op_Implicit((Object)(object)Data.footLeft))
		{
			LeftFootRig = ((Component)Data.footLeft).GetComponent<Rigidbody>();
		}
		HipRig = ((Component)Data.hip).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)Data.head))
		{
			HeadRig = ((Component)Data.head).GetComponent<Rigidbody>();
		}
		AnimationHandler component = ((Component)Data).GetComponent<AnimationHandler>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.multiplier = 0.5f;
		}
		heightVariance *= Random.value;
		Time = Random.Range(0f, 1000f);
		Balance component2 = ((Component)Data).GetComponent<Balance>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			((Behaviour)component2).enabled = false;
		}
		MGameStateManager = ServiceLocator.GetService<GameStateManager>();
		if (setUnitMainRigKinematic && BoltNetwork.IsClient)
		{
			Data.mainRig.isKinematic = true;
		}
	}

	private void FixedUpdate()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Invalid comparison between Unknown and I4
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		if ((!useWingsInPlacement && (int)MGameStateManager.GameState != 1) || !useWings)
		{
			return;
		}
		_ = Data.unit.m_PreferedDistance;
		_ = Data.distanceToTarget;
		RaycastHit val = default(RaycastHit);
		Physics.Raycast(new Ray(((Component)this).transform.position, Vector3.down), ref val, ((Keyframe)(ref flightCurve.keys[flightCurve.keys.Length - 1])).time, LayerMask.op_Implicit(mask));
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref val)).transform))
		{
			float num = ((RaycastHit)(ref val)).distance + Mathf.Cos((Time.time + Time) * variationSpeed) * heightVariance;
			Data.mainRig.AddTorque(rotationTorque * Vector3.Angle(((Component)Data.mainRig).transform.up, Data.groundedMovementDirectionObject.forward) * Vector3.Cross(((Component)Data.mainRig).transform.up, Data.groundedMovementDirectionObject.forward), (ForceMode)5);
			if (Object.op_Implicit((Object)(object)HeadRig))
			{
				HeadRig.AddForce(Vector3.up * flightForce * headM * flightCurve.Evaluate(num), (ForceMode)5);
			}
			Data.mainRig.AddForce(Vector3.up * flightForce * flightCurve.Evaluate(num), (ForceMode)5);
			if (Object.op_Implicit((Object)(object)RightFootRig))
			{
				RightFootRig.AddForce(Vector3.up * flightForce * legForceMultiplier * 0.5f * flightCurve.Evaluate(num), (ForceMode)5);
			}
			if (Object.op_Implicit((Object)(object)RightFootRig))
			{
				LeftFootRig.AddForce(Vector3.up * flightForce * legForceMultiplier * 0.5f * flightCurve.Evaluate(num), (ForceMode)5);
			}
			Data.TouchGround(((RaycastHit)(ref val)).point, ((RaycastHit)(ref val)).normal, (Rigidbody)null);
		}
	}

	public void EnableFlight()
	{
		useWings = true;
	}

	public void DiableFlight()
	{
		useWings = false;
	}
}
public class SpawnWall : MonoBehaviour, IRemotelyControllable
{
	public GameObject objectToSpawn;

	public float percentage = 0.5f;

	public bool spawnOnAwake;

	public int numberToSpawn = 1;

	public bool spawnIfUnitDead = true;

	public bool parentToMe;

	public bool followMe;

	public bool useRootSizeOfSpawner;

	public bool giveTarget;

	public bool allowRootTarget;

	public bool useAlternatingSpawnPos;

	public bool giveSpawnerWeapon;

	public float spread;

	public float timeBetweenSpawns = 0.02f;

	public bool waitBeforeFirstSpawn;

	public bool useRandom;

	public float minRandom = 1f;

	public float maxRandom = 1f;

	public float maxRange;

	private bool DidInitialize;

	public UnityEvent spawnEvent;

	private ProjectilesSpawnManager ProjectilesSpawnManager;

	private bool IsProjectile;

	private GameObject RootObject;

	private DataHandler Data;

	private CheckClosestUnitTargets TargetChecker;

	private float AllowedToSpawn = 1f;

	private float SpawnedSinceDelay;

	private List<Unit> Targets;

	private Unit CurrentTarget;

	private List<AlternatingSpawnPos> AltSpawnPos;

	private int TargetPlace;

	private int CurrentSpawnPosNumber;

	[HideInInspector]
	public GameObject spawnerProjecile;

	private bool DidInitializeForMultiplayer;

	private bool IsUnit;

	public bool IsRemotelyControlled { get; private set; }

	private void Start()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		Data = ((Component)((Component)this).transform.root).GetComponentInChildren<DataHandler>();
		RootObject = ((Component)((Component)this).transform.root).gameObject;
		if (giveTarget)
		{
			TargetChecker = ((Component)this).GetComponent<CheckClosestUnitTargets>();
		}
		if (spawnOnAwake)
		{
			((MonoBehaviour)this).StartCoroutine(SpawnUnit(((Component)this).transform.position, ((Component)this).transform.rotation));
		}
	}

	public void SpawnUpwardsOnLastGroundPos()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)Data))
		{
			((MonoBehaviour)this).StartCoroutine(SpawnUnit(Data.groundMapPosition, Quaternion.LookRotation(Vector3.up)));
		}
		else
		{
			SpawnUpwards();
		}
	}

	public void SpawnUpwardsOnTarget()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		if (!Object.op_Implicit((Object)(object)Data))
		{
			Data = RootObject.GetComponent<Unit>().data;
		}
		if (Object.op_Implicit((Object)(object)Data) && Object.op_Implicit((Object)(object)Data.targetData))
		{
			position = Data.targetData.mainRig.position;
			if (maxRange != 0f && Data.distanceToTarget > maxRange)
			{
				return;
			}
		}
		((MonoBehaviour)this).StartCoroutine(SpawnUnit(position, Quaternion.LookRotation(Vector3.up + Random.insideUnitSphere * spread * 0.01f)));
	}

	public void SpawnOnAndTowardsTarget()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		if (!Object.op_Implicit((Object)(object)Data))
		{
			Data = RootObject.GetComponent<Unit>().data;
		}
		if (Object.op_Implicit((Object)(object)Data) && Object.op_Implicit((Object)(object)Data.targetData))
		{
			position = Data.targetData.mainRig.position;
			if (maxRange != 0f && Data.distanceToTarget > maxRange)
			{
				return;
			}
		}
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Data.targetData.mainRig.position.x - Data.mainRig.position.x, 0f, Data.targetData.mainRig.position.z - Data.mainRig.position.z);
		((MonoBehaviour)this).StartCoroutine(SpawnUnit(position, Quaternion.LookRotation(val + Random.insideUnitSphere * spread * 0.01f)));
	}

	public void SpawnUpwardsOnSpawnerTarget()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		DataHandler val = null;
		TeamHolder component = ((Component)((Component)this).transform.root).GetComponent<TeamHolder>();
		if (Object.op_Implicit((Object)(object)component.spawner))
		{
			val = ((Component)component.spawner.transform.root).GetComponent<Unit>().data;
		}
		if (Object.op_Implicit((Object)(object)val) && Object.op_Implicit((Object)(object)val.targetData))
		{
			position = val.targetData.mainRig.position;
			if (maxRange != 0f && val.distanceToTarget > maxRange)
			{
				return;
			}
		}
		((MonoBehaviour)this).StartCoroutine(SpawnUnit(position, Quaternion.LookRotation(Vector3.up + Random.insideUnitSphere * spread * 0.01f)));
	}

	public void SpawnUpwards()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		((MonoBehaviour)this).StartCoroutine(SpawnUnit(((Component)this).transform.position, Quaternion.LookRotation(Vector3.up + Random.insideUnitSphere * spread * 0.01f)));
	}

	public void SpawnAtObjectRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.rotation * Vector3.forward;
		((MonoBehaviour)this).StartCoroutine(SpawnUnit(((Component)this).transform.position, Quaternion.LookRotation(val + Random.insideUnitSphere * spread * 0.01f)));
	}

	public void SpawnTowardsTarget()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)Data))
		{
			Data = RootObject.GetComponent<Unit>().data;
		}
		if (Object.op_Implicit((Object)(object)Data.targetData))
		{
			Vector3 position = ((Component)this).transform.position;
			Vector3 val = Data.targetData.mainRig.position - Data.mainRig.position;
			((MonoBehaviour)this).StartCoroutine(SpawnUnit(position, Quaternion.LookRotation(((Vector3)(ref val)).normalized + Random.insideUnitSphere * spread * 0.01f)));
		}
	}

	public void SpawnTowardsTargetWithoutY()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)Data))
		{
			Data = RootObject.GetComponent<Unit>().data;
		}
		if (Object.op_Implicit((Object)(object)Data.targetData))
		{
			Vector3 val = new Vector3(Data.targetData.mainRig.position.x - Data.mainRig.position.x, 0f, Data.targetData.mainRig.position.z - Data.mainRig.position.z);
			((MonoBehaviour)this).StartCoroutine(SpawnUnit(rotation: Quaternion.LookRotation(((Vector3)(ref val)).normalized + Random.insideUnitSphere * spread * 0.01f), position: Vector3.Lerp(Data.targetData.mainRig.position, ((Component)this).transform.position, percentage)));
		}
	}

	public void SpawnCharacterForward()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		((MonoBehaviour)this).StartCoroutine(SpawnUnit(((Component)this).transform.position, Quaternion.LookRotation(((Component)((Component)((Component)this).transform.root).GetComponent<Unit>().data.mainRig).transform.forward + Random.insideUnitSphere * spread * 0.01f)));
	}

	public void Spawn(Vector3 position, Vector3 direction)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		((MonoBehaviour)this).StartCoroutine(SpawnUnit(position, Quaternion.LookRotation(direction + Random.insideUnitSphere * spread * 0.01f)));
	}

	private IEnumerator SpawnUnit(Vector3 position, Quaternion rotation)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TargetChecker))
		{
			Targets = new List<Unit>();
			Targets = TargetChecker.GetTargets((float?)maxRange);
		}
		if (waitBeforeFirstSpawn)
		{
			SpawnedSinceDelay = AllowedToSpawn;
		}
		int numberSpawned = 0;
		while (numberSpawned < numberToSpawn)
		{
			InitializeSpawn();
			if (!IsAllowedToSpawnInMultiplayer())
			{
				yield return null;
			}
			if (Object.op_Implicit((Object)(object)Data) && Data.Dead && !spawnIfUnitDead)
			{
				yield return null;
			}
			if (useAlternatingSpawnPos)
			{
				AltSpawnPos = new List<AlternatingSpawnPos>();
				AltSpawnPos.AddRange(((Component)((Component)this).transform.parent).GetComponentsInChildren<AlternatingSpawnPos>());
			}
			if (SpawnedSinceDelay < AllowedToSpawn)
			{
				if (useAlternatingSpawnPos && AltSpawnPos.Count > 0)
				{
					if (CurrentSpawnPosNumber > AltSpawnPos.Count - 1)
					{
						CurrentSpawnPosNumber = 0;
					}
					position = ((Component)AltSpawnPos[CurrentSpawnPosNumber]).transform.position;
					if (numberToSpawn - numberSpawned <= AltSpawnPos.Count && AltSpawnPos[CurrentSpawnPosNumber].useLastSpawnEvent)
					{
						AltSpawnPos[CurrentSpawnPosNumber].InvokeLastSpawnEvent();
					}
					else
					{
						AltSpawnPos[CurrentSpawnPosNumber].InvokeSpawnEvent();
					}
				}
				GameObject val = ((!IsProjectile || !((Object)(object)ProjectilesSpawnManager != (Object)null)) ? Object.Instantiate<GameObject>(objectToSpawn, position, rotation) : ProjectilesSpawnManager.SpawnProjectile(objectToSpawn, position, rotation));
				TeamHolder.AddTeamHolder(val, ((Component)((Component)this).transform).gameObject);
				TeamHolder component = val.GetComponent<TeamHolder>();
				if (giveSpawnerWeapon)
				{
					component.spawnerWeapon = ((Component)((Component)((Component)this).transform).GetComponentInParent<Weapon>()).gameObject;
				}
				SpawnedSinceDelay += 1f;
				if (parentToMe)
				{
					val.transform.SetParent(((Component)this).transform, true);
				}
				if (followMe)
				{
					FollowTransform obj = val.gameObject.AddComponent<FollowTransform>();
					obj.target = ((Component)this).transform;
					obj.destroyOnTargetNull = false;
				}
				if (useRootSizeOfSpawner)
				{
					val.transform.localScale = ((Component)this).transform.root.localScale;
				}
				SpellTarget component2 = val.GetComponent<SpellTarget>();
				if (Object.op_Implicit((Object)(object)TargetChecker) && Targets.Count > 0)
				{
					if (numberSpawned < Targets.Count)
					{
						TargetPlace = numberSpawned;
					}
					else
					{
						TargetPlace = numberSpawned - Targets.Count * Mathf.FloorToInt((float)(numberSpawned / Targets.Count));
					}
				}
				if (Object.op_Implicit((Object)(object)component2))
				{
					if (Object.op_Implicit((Object)(object)TargetChecker) && giveTarget && TargetPlace < Targets.Count)
					{
						CurrentTarget = Targets[TargetPlace];
						DataHandler componentInChildren = ((Component)CurrentTarget).GetComponentInChildren<DataHandler>();
						Vector3 position2 = ((Component)this).transform.position;
						Vector3 position3 = componentInChildren.mainRig.position;
						Rigidbody mainRig = componentInChildren.mainRig;
						((TargetableEffect)component2).DoEffect(position2, position3, mainRig);
					}
					else
					{
						component2.GetTarget();
					}
				}
				TeslaCannon component3 = val.GetComponent<TeslaCannon>();
				if (Object.op_Implicit((Object)(object)component3) && Object.op_Implicit((Object)(object)spawnerProjecile))
				{
					component3.maxTargetChecker = ((Component)spawnerProjecile.transform).GetComponent<TeslaCannon>().maxTargetChecker;
					if (Object.op_Implicit((Object)(object)TargetChecker) && giveTarget && Object.op_Implicit((Object)(object)component3.maxTargetChecker) && component3.maxTargetChecker.CheckIfAllowedToHit())
					{
						Unit component4 = ((Component)((Component)this).transform.root).GetComponent<Unit>();
						if (Targets.Count > 0)
						{
							if (!allowRootTarget && Object.op_Implicit((Object)(object)component4) && (Object)(object)Targets[TargetPlace] == (Object)(object)component4)
							{
								Targets.Remove(Targets[TargetPlace]);
							}
							CurrentTarget = Targets[TargetPlace];
							DataHandler componentInChildren2 = ((Component)CurrentTarget).GetComponentInChildren<DataHandler>();
							TeamHolder component5 = ((Component)this).GetComponent<TeamHolder>();
							component.team = component5.team;
							component.spawner = component5.spawner;
							component3.PlayEffect(((Component)componentInChildren2.mainRig).transform, ((Component)this).transform, component5.spawner);
						}
						else
						{
							Object.Destroy((Object)(object)((Component)this).gameObject);
						}
					}
					else
					{
						Object.Destroy((Object)(object)((Component)this).gameObject);
					}
				}
				numberSpawned++;
				CurrentSpawnPosNumber++;
				UnityEvent obj2 = spawnEvent;
				if (obj2 != null)
				{
					obj2.Invoke();
				}
			}
			else
			{
				SpawnedSinceDelay = 0f;
				float num = ((!useRandom) ? timeBetweenSpawns : Random.Range(timeBetweenSpawns * minRandom, timeBetweenSpawns * maxRandom));
				yield return (object)new WaitForSeconds(num);
			}
		}
		TargetPlace = 0;
	}

	private void InitializeSpawn()
	{
		if (!DidInitialize)
		{
			DidInitialize = true;
			if ((Object)(object)objectToSpawn != (Object)null && (Object)(object)objectToSpawn.GetComponent<Projectile>() != (Object)null)
			{
				IsProjectile = true;
				ProjectilesSpawnManager = ServiceLocator.GetService<ProjectilesSpawnManager>();
			}
		}
	}

	public void SetIsRemotelyControlled(bool isRemotelyControlled)
	{
		IsRemotelyControlled = isRemotelyControlled;
	}

	private bool IsAllowedToSpawnInMultiplayer()
	{
		InitializeForMultiplayer();
		if (!IsUnit && !IsProjectile)
		{
			return true;
		}
		return !IsRemotelyControlled;
	}

	private void InitializeForMultiplayer()
	{
		if (!DidInitializeForMultiplayer)
		{
			DidInitializeForMultiplayer = true;
			if (BoltNetwork.IsRunning && (Object)(object)objectToSpawn != (Object)null)
			{
				IsUnit = (Object)(object)objectToSpawn.GetComponent<Unit>() != (Object)null;
			}
		}
	}
}
public class ThorBehavior : MonoBehaviour
{
	private Unit Unit;

	private bool HoldingRight;

	private bool HoldingLeft;

	public GameObject weaponToGrab;

	public UnityEvent grabEvent = new UnityEvent();

	public UnityEvent ungrabEvent = new UnityEvent();

	private void Start()
	{
		Unit = ((Component)((Component)this).transform.root).GetComponent<Unit>();
	}

	public void GrabHammerRight()
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Expected O, but got Unknown
		if (HoldingRight)
		{
			return;
		}
		HoldingRight = true;
		grabEvent.Invoke();
		Collider[] componentsInChildren = ((Component)((Component)Unit).GetComponentInChildren<HandRight>()).GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = false;
		}
		if (Object.op_Implicit((Object)(object)Unit.holdingHandler))
		{
			Unit.WeaponHandler.fistRefernce = null;
			if (Object.op_Implicit((Object)(object)Unit.holdingHandler.rightObject))
			{
				GameObject gameObject = ((Component)Unit.holdingHandler.rightObject).gameObject;
				Unit.holdingHandler.LetGoOfWeapon(gameObject);
				Object.Destroy((Object)(object)gameObject);
			}
			SetWeapon(Unit, Unit.Team, weaponToGrab, new PropItemData(), (HandType)0, Unit.data.mainRig.rotation, new List<GameObject>());
		}
		else
		{
			if (!Object.op_Implicit((Object)(object)((Component)Unit).GetComponentInChildren<HoldingHandlerMulti>()))
			{
				return;
			}
			HoldingHandlerMulti componentInChildren = ((Component)Unit).GetComponentInChildren<HoldingHandlerMulti>();
			foreach (HandRight mainHand in componentInChildren.mainHands)
			{
				componentInChildren.SetWeapon(((Component)mainHand).gameObject, weaponToGrab);
			}
		}
	}

	public void GrabHammerLeft()
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (HoldingLeft)
		{
			return;
		}
		HoldingLeft = true;
		Collider[] componentsInChildren = ((Component)((Component)Unit).GetComponentInChildren<HandLeft>()).GetComponentsInChildren<Collider>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].enabled = false;
		}
		if (Object.op_Implicit((Object)(object)Unit.holdingHandler))
		{
			weaponToGrab.GetComponent<Holdable>().holdableData.snapConnect = false;
			if (Object.op_Implicit((Object)(object)Unit.holdingHandler.leftObject))
			{
				GameObject gameObject = ((Component)Unit.holdingHandler.leftObject).gameObject;
				Unit.holdingHandler.LetGoOfWeapon(gameObject);
				Object.Destroy((Object)(object)gameObject);
			}
			Unit.holdingHandler.leftHandActivity = (HandActivity)1;
		}
		else
		{
			if (!Object.op_Implicit((Object)(object)((Component)Unit).GetComponentInChildren<HoldingHandlerMulti>()))
			{
				return;
			}
			HoldingHandlerMulti componentInChildren = ((Component)Unit).GetComponentInChildren<HoldingHandlerMulti>();
			foreach (HandLeft otherHand in componentInChildren.otherHands)
			{
				componentInChildren.SetWeapon(((Component)otherHand).gameObject, weaponToGrab);
			}
		}
	}

	public void UnGrabHammer()
	{
		if (HoldingLeft || HoldingRight)
		{
			HoldingLeft = false;
			HoldingRight = false;
			ungrabEvent.Invoke();
			if (Object.op_Implicit((Object)(object)Unit.holdingHandler))
			{
				Unit.holdingHandler.LetGoOfWeapon(weaponToGrab);
			}
			else if (Object.op_Implicit((Object)(object)((Component)Unit).GetComponentInChildren<HoldingHandlerMulti>()))
			{
				((Component)Unit).GetComponentInChildren<HoldingHandlerMulti>().LetGoOfAll(false);
			}
		}
	}

	public Weapon SetWeapon(Unit unit, Team team, GameObject weaponObject, PropItemData weaponData, HandType handType, Quaternion rotation, List<GameObject> objects, bool isUnitEditor = false)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		WeaponHandler componentInChildren = ((Component)unit).GetComponentInChildren<WeaponHandler>();
		if (!Object.op_Implicit((Object)(object)componentInChildren))
		{
			MultipleWeaponHandler componentInChildren2 = ((Component)unit).GetComponentInChildren<MultipleWeaponHandler>();
			if (Object.op_Implicit((Object)(object)componentInChildren2))
			{
				componentInChildren2.SetWeapon(weaponObject, handType, false);
			}
			return null;
		}
		Torso componentInChildren3 = ((Component)unit).GetComponentInChildren<Torso>();
		if (Object.op_Implicit((Object)(object)weaponObject))
		{
			weaponObject.transform.position = ((Component)componentInChildren3).transform.position + ((Component)componentInChildren3).transform.forward * 0.5f;
			weaponObject.transform.rotation = rotation;
			weaponObject.gameObject.transform.SetParent(((Component)unit).transform);
			objects.Add(weaponObject);
			Weapon component = weaponObject.GetComponent<Weapon>();
			WeaponItem component2 = weaponObject.GetComponent<WeaponItem>();
			Holdable component3 = weaponObject.GetComponent<Holdable>();
			weaponObject.GetComponent<MeleeWeapon>();
			RangeWeapon component4 = weaponObject.GetComponent<RangeWeapon>();
			if (unit.unitBlueprint.removeCloseRangeMiss && Object.op_Implicit((Object)(object)component4))
			{
				component4.extraCDInMelee = 0f;
				component4.extraSpreadInMelee = 0f;
			}
			if (Object.op_Implicit((Object)(object)component3))
			{
				if (component3.useAlternaticeForIceGiant && Object.op_Implicit((Object)(object)((Component)unit).GetComponent<IceGiant>()))
				{
					component3.holdableData.relativePosition = component3.iceGiantRelativePosition;
				}
				if ((int)handType == 0)
				{
					unit.holdingHandler.rightHandActivity = (HandActivity)1;
					if (unit.unitBlueprint.holdinigWithTwoHands)
					{
						unit.holdingHandler.leftHandActivity = (HandActivity)1;
					}
					unit.holdingHandler.rightObject = component3;
				}
				else
				{
					unit.holdingHandler.leftHandActivity = (HandActivity)2;
					unit.holdingHandler.leftObject = component3;
					component3.holdableData.relativePosition.x += unit.unitBlueprint.weaponSeparation;
					component3.holdableData.relativePosition.x *= -1f;
					component3.holdableData.upRotation.x *= -1f;
					component3.holdableData.forwardRotation.x *= -1f;
				}
				component3.holdingHandler = unit.holdingHandler;
			}
			else
			{
				Transform val = (((int)handType != 0) ? ((Component)((Component)unit).GetComponentInChildren<HandLeft>()).transform : ((Component)((Component)unit).GetComponentInChildren<HandRight>()).transform);
				weaponObject.transform.position = val.position;
				weaponObject.transform.rotation = val.rotation;
				weaponObject.transform.parent = val;
			}
			componentInChildren.SetWeapon(component, handType);
			component2.Initialize(team);
			if (weaponData != null)
			{
				((CharacterItem)component2).SetPropData(weaponData, team);
			}
			return component;
		}
		return null;
	}
}
namespace Landfall.TABS.AI.Systems.Modifiers
{
	[UpdateAfter(typeof(UpdateBarrier))]
	[UpdateBefore(typeof(PreLateUpdateBarrier))]
	public class CircleTargetSystem : JobComponentSystem
	{
		private struct Filter
		{
			public EntityArray Entities;

			public ComponentDataArray<Direction> Directions;

			[ReadOnly]
			public ComponentDataArray<CircleTarget> CircleTargets;

			[ReadOnly]
			public ComponentDataArray<HasTargetTag> HasTargetTags;

			[ReadOnly]
			public ComponentDataArray<TargetData> TargetDatas;

			[ReadOnly]
			public SubtractiveComponent<IsInPool> IsInPool;

			public readonly int Length;
		}

		private struct Job : IJobParallelFor
		{
			public EntityArray Entities;

			public ComponentDataArray<Direction> Directions;

			[ReadOnly]
			public ComponentDataArray<CircleTarget> CircleTargets;

			[ReadOnly]
			public ComponentDataArray<HasTargetTag> HasTargetTags;

			[ReadOnly]
			public ComponentDataArray<TargetData> TargetDatas;

			[ReadOnly]
			public SubtractiveComponent<IsInPool> IsInPool;

			public Concurrent CommandBuffer;

			public void Execute(int index)
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Unknown result type (might be due to invalid IL or missing references)
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				//IL_0037: Unknown result type (might be due to invalid IL or missing references)
				//IL_004c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
				//IL_0069: Unknown result type (might be due to invalid IL or missing references)
				//IL_006a: Unknown result type (might be due to invalid IL or missing references)
				//IL_006f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0071: Unknown result type (might be due to invalid IL or missing references)
				//IL_007d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0084: Unknown result type (might be due to invalid IL or missing references)
				//IL_0089: Unknown result type (might be due to invalid IL or missing references)
				//IL_008a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009e: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00af: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
				if (!(HasTargetTags[index].Target == Entity.Null))
				{
					Entity val = ((EntityArray)(ref Entities))[index];
					Direction val2 = Directions[index];
					CircleTarget circleTarget = CircleTargets[index];
					float distanceToTarget = TargetDatas[index].DistanceToTarget;
					if (distanceToTarget <= circleTarget.maxCircleDistance && distanceToTarget >= circleTarget.minCircleDistance)
					{
						float3 value = val2.Value;
						float3 val3 = new float3(value.x, 0f, value.z);
						float3 val4 = math.cross(math.normalize(val3), new float3(0f, 1f, 0f));
						float3 val5 = math.length(val3) * val4;
						val2.Value = new float3(val5.x, value.y, val5.z);
					}
					((Concurrent)(ref CommandBuffer)).SetComponent<Direction>(index, val, val2);
				}
			}
		}

		[Inject]
		private Filter m_filter;

		[Inject]
		private PreLateUpdateBarrier m_barrier;

		protected override JobHandle OnUpdate(JobHandle inputDeps)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			Job job = default(Job);
			job.Entities = m_filter.Entities;
			job.Directions = m_filter.Directions;
			job.CircleTargets = m_filter.CircleTargets;
			job.TargetDatas = m_filter.TargetDatas;
			job.HasTargetTags = m_filter.HasTargetTags;
			EntityCommandBuffer val = ((BarrierSystem)m_barrier).CreateCommandBuffer();
			job.CommandBuffer = ((EntityCommandBuffer)(ref val)).ToConcurrent();
			return IJobParallelForExtensions.Schedule<Job>(job, m_filter.Length, 12, inputDeps);
		}
	}
}
namespace Landfall.TABS.AI.Components.Modifiers
{
	public struct CircleTarget : IMovementComponent, IComponentData
	{
		public float minCircleDistance;

		public float maxCircleDistance;
	}
}
namespace HiddenUnits
{
	public class AchillesArmor : MonoBehaviour
	{
		public class UnitIsArmored : MonoBehaviour
		{
			public bool armorActive = true;

			public GameObject projectileHitEffect;

			public GameObject weaponHitEffect;

			public float parryForce;

			public float parryPower;

			public float blockPower;
		}

		private Unit Unit;

		private UnitIsArmored ArmoredUnit;

		private AchillesArmorEvent[] ArmorListeners;

		private bool ArmorDisabled;

		private float ArmorDisabledCounter;

		private float MaxArmorHealth;

		[Header("Armor Settings")]
		public UnityEvent armorDisableEvent = new UnityEvent();

		public UnityEvent armorEnableEvent = new UnityEvent();

		public float armorDisabledTime = 3f;

		[Header("Hit Settings")]
		public GameObject projectileHitEffect;

		public GameObject weaponHitEffect;

		public float parryForce;

		public float parryPower;

		public float blockPower;

		[Header("Health Settings")]
		public float armorHealth = 500f;

		public bool armorRegenerate;

		public float armorRegenerationRate = 5f;

		public bool healthRegenerate;

		public float healthRegenerationRate = 50f;

		public void Start()
		{
			Unit = ((Component)((Component)this).transform.root).GetComponent<Unit>();
			Unit unit = Unit;
			unit.WasDealtDamageAction = (Action<float>)Delegate.Combine(unit.WasDealtDamageAction, new Action<float>(Armor));
			ArmoredUnit = ((Component)Unit).gameObject.AddComponent<UnitIsArmored>();
			ArmoredUnit.projectileHitEffect = projectileHitEffect;
			ArmoredUnit.weaponHitEffect = weaponHitEffect;
			ArmoredUnit.parryForce = parryForce;
			ArmoredUnit.parryPower = parryPower;
			ArmoredUnit.blockPower = blockPower;
			MaxArmorHealth = armorHealth;
			ArmorListeners = ((Component)Unit).GetComponentsInChildren<AchillesArmorEvent>();
		}

		public void Armor(float damage)
		{
			if (ArmorDisabled)
			{
				return;
			}
			DataHandler data = Unit.data;
			data.health += damage;
			armorHealth -= damage;
			armorHealth = Mathf.Clamp(armorHealth, 0f, MaxArmorHealth);
			if (armorHealth <= 0f)
			{
				ArmorDisabled = true;
				armorDisableEvent.Invoke();
				AchillesArmorEvent[] armorListeners = ArmorListeners;
				for (int i = 0; i < armorListeners.Length; i++)
				{
					armorListeners[i].OnArmorDeactivated();
				}
				ArmoredUnit.armorActive = false;
			}
		}

		public void Update()
		{
			if (ArmorDisabled)
			{
				ArmorDisabledCounter += Time.deltaTime;
				if (ArmorDisabledCounter >= armorDisabledTime)
				{
					ArmorDisabledCounter = 0f;
					ArmorDisabled = false;
					armorHealth = MaxArmorHealth;
					armorEnableEvent.Invoke();
					AchillesArmorEvent[] armorListeners = ArmorListeners;
					for (int i = 0; i < armorListeners.Length; i++)
					{
						armorListeners[i].OnArmorActivated();
					}
					ArmoredUnit.armorActive = true;
				}
			}
			else
			{
				if (armorRegenerate)
				{
					armorHealth += Time.deltaTime * armorRegenerationRate;
					armorHealth = Mathf.Clamp(armorHealth, 0f, MaxArmorHealth);
				}
				if (healthRegenerate)
				{
					DataHandler data = Unit.data;
					data.health += Time.deltaTime * healthRegenerationRate;
					Unit.data.health = Mathf.Clamp(Unit.data.health, 0f, Unit.data.maxHealth);
				}
			}
		}
	}
	public class AchillesArmorEvent : MonoBehaviour
	{
		public UnityEvent armorActivationEvent = new UnityEvent();

		public UnityEvent armorDeactivationEvent = new UnityEvent();

		public void OnArmorActivated()
		{
			armorActivationEvent.Invoke();
		}

		public void OnArmorDeactivated()
		{
			armorDeactivationEvent.Invoke();
		}
	}
	public class AddEffectIfTargetingSelf : MonoBehaviour
	{
		public float checkRadius;

		public bool onlyOnce;

		public UnitEffectBase effect;

		public void DoCheck()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			RaycastHit[] array = Physics.SphereCastAll(((Component)this).transform.position, checkRadius, Vector3.up, 0.1f, LayerMask.GetMask(new string[1] { "MainRig" }));
			List<Unit> list = new List<Unit>();
			RaycastHit[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				RaycastHit val = array2[i];
				if (Object.op_Implicit((Object)(object)((Component)((RaycastHit)(ref val)).transform.root).GetComponent<Unit>()) && !list.Contains(((Component)((RaycastHit)(ref val)).transform.root).GetComponent<Unit>()))
				{
					list.Add(((Component)((Component)((RaycastHit)(ref val)).rigidbody).transform.root).GetComponent<Unit>());
				}
			}
			Unit[] array3 = (from Unit unit in list
				where !unit.data.Dead && Object.op_Implicit((Object)(object)unit.data.targetData.unit) && (Object)(object)unit.data.targetData.unit == (Object)(object)((Component)((Component)this).transform.root).GetComponent<Unit>()
				select unit).ToArray();
			if (array3.Length == 0)
			{
				return;
			}
			Unit[] array4 = array3;
			foreach (Unit val2 in array4)
			{
				UnitEffectBase val3 = UnitEffectBase.AddEffectToTarget(((Component)((Component)val2).transform).gameObject, effect);
				if ((Object)(object)val3 == (Object)null)
				{
					GameObject obj = Object.Instantiate<GameObject>(((Component)effect).gameObject, ((Component)val2).transform.root);
					obj.transform.position = ((Component)val2).transform.position;
					val3 = obj.GetComponent<UnitEffectBase>();
					TeamHolder.AddTeamHolder(obj, ((Component)((Component)this).transform.root).gameObject);
					val3.DoEffect();
				}
				else if (!onlyOnce)
				{
					val3.Ping();
				}
			}
		}
	}
	public class Afterimage : MonoBehaviour
	{
		private UnitSpawner Spawner;

		public Material imgMaterial;

		public GameObject poofEffect;

		public float fadeTime = 5f;

		public float destroyDelay = 0.2f;

		public void Start()
		{
			Spawner = ((Component)this).GetComponent<UnitSpawner>();
			Spawner.unitBlueprint = ((Component)((Component)this).transform.root).GetComponent<Unit>().unitBlueprint;
			UnitSpawner spawner = Spawner;
			spawner.spawnUnitAction = (Action<GameObject>)Delegate.Combine(spawner.spawnUnitAction, new Action<GameObject>(SpawnAfterimage));
		}

		public void SpawnAfterimage(GameObject unit)
		{
			((MonoBehaviour)this).StartCoroutine(Spawn(unit));
		}

		private IEnumerator Spawn(GameObject u)
		{
			((Object)u).name = "AFTERIMAGE";
			Unit unit = u.GetComponent<Unit>();
			((Component)unit.data).GetComponent<UnitColorHandler>().SetMaterial(imgMaterial);
			u.GetComponent<UnitAPI>().forceSupressFromWinCondition = true;
			unit.targetingPriorityMultiplier = 0.1f;
			ConditionalEvent[] componentsInChildren = u.GetComponentsInChildren<ConditionalEvent>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				Object.Destroy((Object)(object)((Component)componentsInChildren[i]).gameObject);
			}
			ProjectileDodgeMove[] componentsInChildren2 = u.GetComponentsInChildren<ProjectileDodgeMove>();
			for (int i = 0; i < componentsInChildren2.Length; i++)
			{
				Object.Destroy((Object)(object)((Component)componentsInChildren2[i]).gameObject);
			}
			Object.Instantiate<GameObject>(poofEffect, unit.data.mainRig.position, poofEffect.transform.rotation);
			yield return (object)new WaitForSeconds(0.1f);
			Object.Instantiate<GameObject>(poofEffect, ((Component)((Component)this).transform.root).GetComponent<Unit>().data.mainRig.position, poofEffect.transform.rotation);
			yield return (object)new WaitForSeconds(fadeTime - 0.1f);
			Object.Instantiate<GameObject>(poofEffect, unit.data.mainRig.position, poofEffect.transform.rotation);
			yield return (object)new WaitForSeconds(destroyDelay);
			TrailRenderer[] componentsInChildren3 = u.GetComponentsInChildren<TrailRenderer>();
			foreach (TrailRenderer val in componentsInChildren3)
			{
				((Component)val).transform.SetParent((Transform)null);
				val.emitting = false;
				((Component)val).gameObject.AddComponent<RemoveAfterSeconds>().seconds = val.time * 1.5f;
			}
			unit.DestroyUnit();
		}
	}
	public class AngelBubble : MonoBehaviour
	{
		private Rigidbody[] HitRigs;

		private Unit[] HitUnits;

		private Transform EffectTransform;

		[Header("Damage Settings")]
		public float radius = 5f;

		public float force = 1000f;

		public float minMassCap = 60f;

		public float damageOverTime = 60f;

		[Header("Curve Settings")]
		public AnimationCurve influenceCurve;

		public AnimationCurve upCurve;

		private void Start()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			EffectTransform = ((Component)this).transform.GetChild(0);
			Collider[] source = Physics.OverlapSphere(EffectTransform.position, radius);
			HitRigs = (from x in source
				select x.attachedRigidbody into x
				where Object.op_Implicit((Object)(object)x)
				select x).Distinct().ToArray();
			HitUnits = (from hit in source
				select ((Component)((Component)hit).transform.root).GetComponent<Unit>() into x
				where Object.op_Implicit((Object)(object)x) && !x.data.Dead
				select x).OrderBy(delegate(Unit x)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				Vector3 val = ((Component)x.data.mainRig).transform.position - ((Component)this).transform.position;
				return ((Vector3)(ref val)).magnitude;
			}).Distinct().ToArray();
			((MonoBehaviour)this).StartCoroutine(AnimateSpell());
		}

		private IEnumerator AnimateSpell()
		{
			float time = ((Keyframe)(ref upCurve.keys[upCurve.keys.Length - 1])).time;
			float t = 0f;
			Vector3 startPos = EffectTransform.position;
			while (t < time)
			{
				t += Time.deltaTime;
				Pull();
				EffectTransform.position = startPos + Vector3.up * upCurve.Evaluate(t);
				yield return null;
			}
		}

		private void Pull()
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0116: Unknown result type (might be due to invalid IL or missing references)
			foreach (Rigidbody item in HitRigs.Where((Rigidbody x) => Object.op_Implicit((Object)(object)x)))
			{
				Vector3 position = EffectTransform.position;
				float num = influenceCurve.Evaluate(Vector3.Distance(item.position, position));
				float num2 = Random.Range(0.5f, 1f);
				float num3 = num2 * force * num;
				Vector3 val = position + Random.insideUnitSphere * 2f - item.position;
				WilhelmPhysicsFunctions.AddForceWithMinWeight(item, num3 * ((Vector3)(ref val)).normalized, (ForceMode)0, minMassCap);
				item.AddForce(-200f * num2 * Time.deltaTime * item.velocity, (ForceMode)5);
			}
			Unit[] hitUnits = HitUnits;
			for (int i = 0; i < hitUnits.Length; i++)
			{
				((Damagable)hitUnits[i].data.healthHandler).TakeDamage(damageOverTime * Time.deltaTime, Vector3.up, (Unit)null, (DamageType)0);
			}
		}
	}
	public class AttachWebToMage : MonoBehaviour
	{
		public void Start()
		{
			Attach();
		}

		public void Attach()
		{
			if (Object.op_Implicit((Object)(object)((Component)((Component)this).transform.parent.parent).GetComponent<TeamHolder>()) && Object.op_Implicit((Object)(object)((Component)((Component)this).transform.parent.parent).GetComponent<TeamHolder>().spawnerWeapon) && Object.op_Implicit((Object)(object)((Component)((Component)this).transform.parent.parent).GetComponent<TeamHolder>().spawnerWeapon.transform))
			{
				((Component)this).transform.SetParent(((Component)((Component)this).transform.parent.parent).GetComponent<TeamHolder>().spawnerWeapon.transform);
			}
		}
	}
	public class BillyKeys : GameStateListener
	{
		private class BillyKey
		{
			public readonly GameObject key;

			public readonly string alreadyUnlocked;

			public readonly string toBeUnlocked;

			public readonly bool isUnlocking;

			public BillyKey(GameObject key, string alreadyUnlocked, string toBeUnlocked, bool isUnlocking)
			{
				this.key = key;
				this.alreadyUnlocked = alreadyUnlocked;
				this.toBeUnlocked = toBeUnlocked;
				this.isUnlocking = isUnlocking;
			}
		}

		private Transform MainCam;

		private ISaveLoaderService Save;

		private List<bool> IsUnlocking = new List<bool>();

		private RotationShake RotationShake;

		private Rigidbody SecretObject;

		private AudioSource LoopSource;

		private bool Done;

		private float UnlockValue;

		[Header("Keys")]
		public List<GameObject> keys = new List<GameObject>();

		public List<string> alreadyUnlocked = new List<string>();

		public List<string> toBeUnlocked = new List<string>();

		[Header("Final Unlock")]
		public UnityEvent unlockAllEvent = new UnityEvent();

		public float unlockDelay = 2f;

		public float unlockDistance = 4f;

		public string finalUnlock;

		public string unlockDescription;

		public Sprite unlockImage;

		public AudioClip hitClip;

		public Color glowColor;

		public override void OnEnterNewScene()
		{
			((GameStateListener)this).OnEnterNewScene();
			PlayerCamerasManager service = ServiceLocator.GetService<PlayerCamerasManager>();
			MainCam = ((service != null) ? ((Component)service.GetMainCam((Player)0)).transform : null);
			Save = ServiceLocator.GetService<ISaveLoaderService>();
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponentInChildren<RotationShake>()))
			{
				RotationShake = ((Component)this).GetComponentInChildren<RotationShake>();
			}
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponentInChildren<Rigidbody>()))
			{
				SecretObject = ((Component)this).GetComponentInChildren<Rigidbody>();
			}
			LoopSource = ((Component)this).GetComponent<AudioSource>();
			List<BillyKey> list = new List<BillyKey>();
			if (keys.Count > 0)
			{
				for (int i = 0; i < keys.Count; i++)
				{
					IsUnlocking.Add(item: false);
					if (Save.HasUnlockedSecret(toBeUnlocked[i]))
					{
						keys[i].SetActive(true);
						keys[i].GetComponent<Animator>().Play("BillyKey");
						list.Add(new BillyKey(keys[i], alreadyUnlocked[i], toBeUnlocked[i], IsUnlocking[i]));
					}
				}
			}
			foreach (BillyKey item in list)
			{
				keys.Remove(item.key);
				alreadyUnlocked.Remove(item.alreadyUnlocked);
				toBeUnlocked.Remove(item.toBeUnlocked);
				IsUnlocking.Remove(item.isUnlocking);
			}
			CheckUnlocks();
		}

		public override void OnEnterPlacementState()
		{
		}

		public override void OnEnterBattleState()
		{
		}

		public void Update()
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			if (Save.HasUnlockedSecret(finalUnlock))
			{
				return;
			}
			float num = Vector3.Distance(SecretObject.worldCenterOfMass, MainCam.position);
			float num2 = Vector3.Angle(MainCam.forward, SecretObject.worldCenterOfMass - MainCam.position);
			float num3 = 1000f / (num * num2);
			LoopSource.volume = Mathf.Pow(UnlockValue * 0.25f, 1.3f);
			LoopSource.pitch = 1f + 1f * UnlockValue;
			if (Done)
			{
				if (UnlockValue > 0f || num3 > 10f)
				{
					SetColor();
				}
				if (num > unlockDistance)
				{
					UnlockValue -= Time.unscaledDeltaTime * 0.2f;
				}
				else if (num3 > 8f)
				{
					UnlockValue += Time.unscaledDeltaTime * 0.2f;
					UnlockProgressFeedback();
					if (UnlockValue > 1f)
					{
						UnlockSelf();
					}
				}
				else
				{
					UnlockValue -= Time.unscaledDeltaTime * 0.2f;
				}
				return;
			}
			for (int i = 0; i < keys.Count; i++)
			{
				if (Save.HasUnlockedSecret(alreadyUnlocked[i]) && !Save.HasUnlockedSecret(toBeUnlocked[i]) && !IsUnlocking[i] && num3 > 8f)
				{
					((MonoBehaviour)this).StartCoroutine(UnlockKey(i));
				}
			}
		}

		public IEnumerator UnlockKey(int index)
		{
			IsUnlocking[index] = true;
			keys[index].SetActive(true);
			keys[index].GetComponent<Animator>().Play("BillyKey");
			yield return (object)new WaitForSeconds(unlockDelay);
			Save.UnlockSecret(toBeUnlocked[index]);
			LoopSource.Stop();
			LoopSource.volume = 1f;
			LoopSource.PlayOneShot(hitClip);
			CheckUnlocks();
		}

		public void CheckUnlocks()
		{
			if (toBeUnlocked.TrueForAll((string x) => Save.HasUnlockedSecret(toBeUnlocked[toBeUnlocked.IndexOf(x)])))
			{
				Done = true;
				LoopSource.Play();
			}
		}

		public void UnlockSelf()
		{
			if (!Save.HasUnlockedSecret(finalUnlock))
			{
				Save.UnlockSecret(finalUnlock);
				ServiceLocator.GetService<ModalPanel>().OpenUnlockPanel(unlockDescription, unlockImage);
				PlacementUI val = Object.FindObjectOfType<PlacementUI>();
				if ((Object)(object)val != (Object)null)
				{
					val.RedrawUI(finalUnlock);
				}
				LoopSource.PlayOneShot(hitClip);
				unlockAllEvent.Invoke();
				((MonoBehaviour)this).StartCoroutine(ShrinkUnlockValue());
			}
		}

		public IEnumerator ShrinkUnlockValue()
		{
			while (UnlockValue > 0f)
			{
				UnlockValue -= Time.unscaledDeltaTime * 0.2f;
				SetColor();
				UnlockProgressFeedback();
				LoopSource.volume = Mathf.Pow(UnlockValue * 0.25f, 1.3f);
				LoopSource.pitch = 1f + 1f * UnlockValue;
				yield return null;
			}
		}

		private void SetColor()
		{
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			UnlockValue = Mathf.Clamp(UnlockValue, 0f, float.PositiveInfinity);
			Renderer[] componentsInChildren = ((Component)this).GetComponentsInChildren<Renderer>();
			foreach (Renderer val in componentsInChildren)
			{
				if (Object.op_Implicit((Object)(object)((Component)val).GetComponent<ParticleSystemRenderer>()))
				{
					continue;
				}
				Material[] materials = val.materials;
				for (int j = 0; j < materials.Length; j++)
				{
					if (materials[j].HasProperty("_EmissionColor"))
					{
						materials[j].EnableKeyword("_EMISSION");
						materials[j].SetColor("_EmissionColor", glowColor * UnlockValue * 2f);
					}
				}
				val.materials = materials;
			}
		}

		private void UnlockProgressFeedback()
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)RotationShake))
			{
				if (UnlockValue <= 0f)
				{
					RotationShake.AddForce(Random.onUnitSphere * 2f);
					UnlockValue = 0f;
				}
				((Behaviour)RotationShake).enabled = true;
				RotationShake.AddForce(Random.onUnitSphere * UnlockValue * Time.deltaTime * 50f);
			}
		}
	}
	public class BillyLaser : MonoBehaviour
	{
		private List<Unit> HitList = new List<Unit>();

		public float damage = 100f;

		public float knockback = 100f;

		public float massCap = 10f;

		public bool canHitMultipleTimes = true;

		private CollisionWeaponEffect[] CollisionEffects;

		public UnityEvent collisionEvent;

		public void Start()
		{
			CollisionEffects = ((Component)this).GetComponentsInChildren<CollisionWeaponEffect>();
		}

		public void OnTriggerStay(Collider col)
		{
			DoDamage(col);
		}

		public void OnTriggerEnter(Collider col)
		{
			DoDamage(col);
		}

		public void DoDamage(Collider col)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Expected O, but got Unknown
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_020b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)col.attachedRigidbody) && Object.op_Implicit((Object)(object)((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>()) && ((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>().Team != ((Component)((Component)this).transform.root).GetComponent<Unit>().Team && !((Object)(object)((Component)col.attachedRigidbody).transform.root == (Object)(object)((Component)this).transform.root) && ((Component)col.attachedRigidbody).transform.IsChildOf(((Component)((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>().data).transform) && (!Object.op_Implicit((Object)(object)((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>()) || !HitList.Contains(((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>())))
			{
				Unit component = ((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>();
				CollisionWeaponEffect[] collisionEffects = CollisionEffects;
				for (int i = 0; i < collisionEffects.Length; i++)
				{
					collisionEffects[i].DoEffect(((Component)col).transform, new Collision());
				}
				collisionEvent.Invoke();
				((Damagable)component.data.healthHandler).TakeDamage(damage, Vector3.zero, ((Component)((Component)this).transform.root).GetComponent<Unit>(), (DamageType)1);
				float num = Mathf.Clamp(col.attachedRigidbody.drag / 3f, 0.1f, 1f);
				WilhelmPhysicsFunctions.AddAxplosionForceWithMinWeight(col.attachedRigidbody, knockback * num, ((Component)this).transform.position, 3f, (ForceMode)1, massCap);
				Rigidbody attachedRigidbody = col.attachedRigidbody;
				attachedRigidbody.velocity *= 0.9f;
				WilhelmPhysicsFunctions.AddAxplosionForceWithMinWeight(component.data.mainRig, knockback * num, ((Component)this).transform.position, 3f, (ForceMode)1, massCap);
				Rigidbody mainRig = component.data.mainRig;
				mainRig.velocity *= 0.9f;
				if (!canHitMultipleTimes)
				{
					HitList.Add(component);
				}
			}
		}

		public void ClearHits()
		{
			HitList.Clear();
		}
	}
	public class ChangeEyes : MonoBehaviour
	{
		private Unit OwnUnit;

		private EyeSpawner EyeSet;

		private GameObject OriginalEye;

		public GameObject newEye;

		private void Start()
		{
			OwnUnit = ((Component)((Component)this).transform.root).GetComponent<Unit>();
			EyeSet = ((Component)OwnUnit).GetComponentInChildren<EyeSpawner>();
			OriginalEye = EyeSet.eyeObject;
		}

		public void DoEyeChange()
		{
			if (!Object.op_Implicit((Object)(object)EyeSet))
			{
				return;
			}
			foreach (GooglyEye spawnedEye in EyeSet.spawnedEyes)
			{
				GooglyEyes.instance.eyes.Remove(spawnedEye);
				Object.Destroy((Object)(object)((Component)spawnedEye).gameObject);
			}
			EyeSet.spawnedEyes.Clear();
			EyeSet[] eyeSets = EyeSet.eyeSets;
			for (int i = 0; i < eyeSets.Length; i++)
			{
				eyeSets[i].useCurves = false;
			}
			EyeSet.eyeObject = newEye;
			((object)EyeSet).GetType().GetMethod("Awake", BindingFlags.Instance | BindingFlags.NonPublic)?.Invoke(EyeSet, new object[0]);
		}

		public void DoEyeReset()
		{
			if (!Object.op_Implicit((Object)(object)EyeSet))
			{
				return;
			}
			foreach (GooglyEye spawnedEye in EyeSet.spawnedEyes)
			{
				GooglyEyes.instance.eyes.Remove(spawnedEye);
				Object.Destroy((Object)(object)((Component)spawnedEye).gameObject);
			}
			EyeSet.spawnedEyes.Clear();
			EyeSet.eyeObject = OriginalEye;
			((object)EyeSet).GetType().GetMethod("Awake", BindingFlags.Instance | BindingFlags.NonPublic)?.Invoke(EyeSet, new object[0]);
		}
	}
	public class ChickenSticks : MonoBehaviour
	{
		public enum ClubState
		{
			Idle,
			Swinging,
			Roaming,
			Disabled
		}

		private Rigidbody Rig;

		public ClubState currentState;

		[Header("Idle")]
		public Transform hoverTarget;

		public Vector3 offset;

		public float idleDrag = 0.8f;

		public float idleForce;

		public float idleAngularForce;

		public float idleDragAmount;

		[Header("Swinging")]
		public float returnDelay = 1f;

		public float swingingDragAmount;

		[Header("Roaming")]
		public UnityEvent roamingBeginEvent = new UnityEvent();

		public UnityEvent roamingEndEvent = new UnityEvent();

		public float roamingTimer = 5f;

		public float targetingRadius = 10f;

		public float roamingForce;

		public float roamingTorque;

		public float roamingDragAmount;

		private Unit RoamingTarget;

		private List<Unit> HitList = new List<Unit>();

		[Header("Damage")]
		public float damage = 120f;

		public float knockback = 100f;

		public float massCap = 25f;

		public float impactMultiplier = 1f;

		public float screenShakeAmount = 1f;

		public float damageCooldown = 0.01f;

		public float disableDamageDelay = 0.3f;

		public bool dealDamageOutsideOfSwing;

		private float DamageCounter;

		private bool CanDealDamage = true;

		public void Start()
		{
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			Rig = ((Component)this).GetComponent<Rigidbody>();
			offset = (Vector3)(Object.op_Implicit((Object)(object)((Component)this).GetComponentInParent<Holdable>().hl) ? new Vector3(0f - offset.x, offset.y, offset.z) : offset);
		}

		public void Update()
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_0103: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0112: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			//IL_018d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_019a: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0202: Unknown result type (might be due to invalid IL or missing references)
			//IL_0212: Unknown result type (might be due to invalid IL or missing references)
			//IL_021c: Unknown result type (might be due to invalid IL or missing references)
			DamageCounter += Time.deltaTime;
			Vector3 val;
			if (currentState == ClubState.Idle && Object.op_Implicit((Object)(object)hoverTarget))
			{
				Rig.AddForce((hoverTarget.TransformPoint(offset) - ((Component)this).transform.position) * idleForce, (ForceMode)5);
				Rigidbody rig = Rig;
				rig.velocity *= idleDrag;
				Rigidbody rig2 = Rig;
				rig2.angularVelocity *= idleDrag;
				Rigidbody rig3 = Rig;
				val = Vector3.Cross(((Component)this).transform.forward, hoverTarget.forward);
				rig3.AddTorque(((Vector3)(ref val)).normalized * Vector3.Angle(((Component)this).transform.forward, hoverTarget.forward) * idleAngularForce, (ForceMode)5);
				Rigidbody rig4 = Rig;
				val = Vector3.Cross(((Component)this).transform.up, Vector3.up);
				rig4.AddTorque(((Vector3)(ref val)).normalized * Vector3.Angle(((Component)this).transform.up, Vector3.up) * idleAngularForce * 0.2f, (ForceMode)5);
			}
			else if (currentState == ClubState.Roaming)
			{
				if (Object.op_Implicit((Object)(object)RoamingTarget))
				{
					Rigidbody rig5 = Rig;
					val = RoamingTarget.data.mainRig.position - ((Component)this).transform.position;
					rig5.AddForce(((Vector3)(ref val)).normalized * roamingForce * Rig.mass * Time.deltaTime);
					Rigidbody rig6 = Rig;
					val = RoamingTarget.data.mainRig.position - ((Component)this).transform.position;
					rig6.AddTorque(((Vector3)(ref val)).normalized * roamingTorque * Rig.mass * Time.deltaTime);
				}
				else
				{
					SetTarget(targetingRadius);
				}
			}
		}

		public void SetState(ClubState state)
		{
			currentState = state;
			HitList.Clear();
			if (state == ClubState.Idle)
			{
				Rig.drag = idleDragAmount;
			}
			if (state == ClubState.Swinging)
			{
				Rig.drag = swingingDragAmount;
			}
			if (state == ClubState.Roaming)
			{
				Rig.drag = roamingDragAmount;
			}
			if (state == ClubState.Disabled)
			{
				Rig.drag = 0f;
			}
		}

		public void SetStateDisabled()
		{
			SetState(ClubState.Disabled);
		}

		public void Swing()
		{
			((MonoBehaviour)this).StartCoroutine(DoSwing());
		}

		public IEnumerator DoSwing()
		{
			yield return (object)new WaitUntil((Func<bool>)(() => currentState == ClubState.Idle));
			SetState(ClubState.Swinging);
			CanDealDamage = true;
			yield return (object)new WaitForSeconds(returnDelay);
			SetState(ClubState.Idle);
			if (!dealDamageOutsideOfSwing)
			{
				yield return (object)new WaitForSeconds(disableDamageDelay);
				CanDealDamage = false;
			}
		}

		public void Roam()
		{
			((MonoBehaviour)this).StartCoroutine(StartRoaming());
		}

		public IEnumerator StartRoaming()
		{
			yield return (object)new WaitUntil((Func<bool>)(() => currentState == ClubState.Idle));
			SetState(ClubState.Roaming);
			SetTarget(50f);
			roamingBeginEvent.Invoke();
			yield return (object)new WaitForSeconds(roamingTimer);
			SetState(ClubState.Idle);
			roamingEndEvent.Invoke();
		}

		public void OnCollisionEnter(Collision col)
		{
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0189: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_019d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
			Unit component = ((Component)col.transform.root).GetComponent<Unit>();
			if (!(DamageCounter < damageCooldown) && Object.op_Implicit((Object)(object)component) && Object.op_Implicit((Object)(object)col.rigidbody) && (!Object.op_Implicit((Object)(object)component) || !HitList.Contains(component)) && (!Object.op_Implicit((Object)(object)component) || component.Team != ((Component)((Component)this).transform.root).GetComponent<Unit>().Team) && CanDealDamage)
			{
				DamageCounter = 0f;
				bool flag = col.transform.IsChildOf(((Component)component.data).transform);
				((Damagable)component.data.healthHandler).TakeDamage(damage * (flag ? 1f : 0f), Vector3.zero, (Unit)null, (DamageType)0);
				Vector3 impulse = col.impulse;
				float num = Mathf.Clamp(((Vector3)(ref impulse)).magnitude / (((Component)this).GetComponent<Rigidbody>().mass + 10f) * 0.3f * impactMultiplier, 0f, 2f);
				if (Object.op_Implicit((Object)(object)ScreenShake.Instance))
				{
					ScreenShake.Instance.AddForce(((Component)this).transform.forward * Mathf.Sqrt(num * 0.5f) * 0.5f * screenShakeAmount, ((ContactPoint)(ref col.contacts[0])).point);
				}
				WilhelmPhysicsFunctions.AddForceWithMinWeight(component.data.mainRig, Mathf.Sqrt(num * 50f) * ((Component)this).transform.forward * knockback * (flag ? 1f : 0f), (ForceMode)1, massCap);
				WilhelmPhysicsFunctions.AddForceWithMinWeight(col.rigidbody, Mathf.Sqrt(num * 50f) * ((Component)this).transform.forward * knockback, (ForceMode)1, massCap);
				CollisionWeaponEffect[] components = ((Component)this).GetComponents<CollisionWeaponEffect>();
				for (int i = 0; i < components.Length; i++)
				{
					components[i].DoEffect(col.transform, col);
				}
				if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<CollisionSound>()))
				{
					((Component)this).GetComponent<CollisionSound>().DoEffect(col.transform, col, num);
				}
				HitList.Add(component);
				if (currentState == ClubState.Roaming)
				{
					SetTarget(targetingRadius);
				}
			}
		}

		public void SetTarget(float range)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			Unit[] array = (from hit in Physics.SphereCastAll(((Component)this).transform.position, range, Vector3.up, 0.1f, LayerMask.GetMask(new string[1] { "MainRig" }))
				select ((Component)((RaycastHit)(ref hit)).transform.root).GetComponent<Unit>() into x
				where Object.op_Implicit((Object)(object)x) && !x.data.Dead && x.Team != ((Component)((Component)this).transform.root).GetComponent<Unit>().Team && !HitList.Contains(x)
				select x).OrderBy(delegate(Unit x)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				Vector3 val = ((Component)x.data.mainRig).transform.position - ((Component)this).transform.position;
				return ((Vector3)(ref val)).magnitude;
			}).Distinct().ToArray();
			if (array.Length != 0)
			{
				RoamingTarget = array[Random.Range(0, array.Length - 1)];
			}
		}
	}
	public class Effect_Garlic : UnitEffectBase
	{
		private Unit OwnUnit;

		private float Amount;

		private float Counter;

		private Vector3 Direction;

		private bool Done;

		public UnityEvent doEffectEvent = new UnityEvent();

		public UnityEvent pingEvent = new UnityEvent();

		[Header("Vampire")]
		public UnityEvent banishVampireEvent = new UnityEvent();

		public UnityEvent hurtVampireEvent = new UnityEvent();

		public float vampireDamage;

		[Header("Non-Vampire")]
		public float multiplier = 1f;

		public float torque = 1f;

		public float force = 1f;

		public float runTime = 3f;

		private void Init()
		{
			OwnUnit = ((Component)((Component)this).transform.root).GetComponent<Unit>();
		}

		public override void DoEffect()
		{
			doEffectEvent.Invoke();
		}

		public override void Ping()
		{
			pingEvent.Invoke();
		}

		private void Update()
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0147: Unknown result type (might be due to invalid IL or missing references)
			//IL_014c: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)OwnUnit) || Done)
			{
				return;
			}
			Counter += Time.deltaTime;
			if (Counter < runTime)
			{
				OwnUnit.unitConfusion = Amount * multiplier * Direction;
				Counter += Time.deltaTime;
				if (Object.op_Implicit((Object)(object)OwnUnit.data.weaponHandler))
				{
					OwnUnit.data.weaponHandler.StopAttacksFor(1f);
				}
				Vector3 forward = ((Component)OwnUnit.data.mainRig).transform.forward;
				OwnUnit.data.mainRig.AddTorque(torque * Vector2.Angle(Vector2.op_Implicit(forward), Vector2.op_Implicit(Direction)) * Time.deltaTime * Vector3.up, (ForceMode)5);
				Rigidbody[] allRigs = OwnUnit.data.allRigs.AllRigs;
				foreach (Rigidbody val in allRigs)
				{
					if (Object.op_Implicit((Object)(object)val))
					{
						val.AddForce(force * Time.deltaTime * Mathf.Clamp(val.drag, 0f, 1f) * Direction, (ForceMode)5);
					}
				}
				OwnUnit.data.mainRig.AddForce(force * Mathf.Clamp(OwnUnit.data.mainRig.drag, 0f, 1f) * Time.deltaTime * Direction, (ForceMode)5);
			}
			else if (!Done)
			{
				Done = true;
				OwnUnit.unitConfusion = Vector3.zero;
			}
		}

		public void DoTheThing()
		{
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			Init();
			if (Object.op_Implicit((Object)(object)OwnUnit) && Object.op_Implicit((Object)(object)OwnUnit.data) && Object.op_Implicit((Object)(object)OwnUnit.data.targetData) && !Object.op_Implicit((Object)(object)((Component)OwnUnit).GetComponentInChildren<IsVampire>()))
			{
				Amount += 1.5f / Mathf.Clamp(OwnUnit.data.maxHealth * 0.02f, 0.1f, float.PositiveInfinity);
				Vector3 val = OwnUnit.data.targetData.mainRig.position - OwnUnit.data.mainRig.position;
				Direction = -((Vector3)(ref val)).normalized;
				Direction.y = 0.2f;
				Direction = ((Vector3)(ref Direction)).normalized;
				Counter = 0f;
			}
			else if (Object.op_Implicit((Object)(object)OwnUnit) && Object.op_Implicit((Object)(object)OwnUnit.data) && Object.op_Implicit((Object)(object)OwnUnit.data.targetData))
			{
				bool num = OwnUnit.data.health <= vampireDamage;
				((Damagable)OwnUnit.data.healthHandler).TakeDamage(vampireDamage, Vector3.zero, OwnUnit, (DamageType)3);
				if (num)
				{
					banishVampireEvent.Invoke();
				}
				else
				{
					hurtVampireEvent.Invoke();
				}
			}
		}
	}
	public class Effect_Petrification : UnitEffectBase
	{
		private Unit OwnUnit;

		private UnitColorHandler ColorHandler;

		private DragHandler DragHandler;

		private RigidbodyHolder AllRigs;

		private List<Vector2> OriginalDrags;

		private List<Rigidbody> Weapons = new List<Rigidbody>();

		private float TrueDelay;

		[Header("Petrification")]
		public UnityEvent petrifyEvent = new UnityEvent();

		public UnitColorInstance petrifyColor;

		public float petrifySpeed = 2f;

		[Header("De-Petrification")]
		public UnityEvent unPetrifyEvent = new UnityEvent();

		public float unPetrifyDelay = 4f;

		public float unPetrifySpeed = 4f;

		[Header("Ping")]
		public UnityEvent pingEvent = new UnityEvent();

		public override void DoEffect()
		{
			OwnUnit = ((Component)((Component)this).transform.root).GetComponent<Unit>();
			ColorHandler = ((Component)OwnUnit.data).GetComponent<UnitColorHandler>();
			DragHandler = ((Component)OwnUnit.data).GetComponent<DragHandler>();
			AllRigs = OwnUnit.data.allRigs;
			OriginalDrags = OwnUnit.data.allRigs.defaultDrags.ToList();
			HoldingHandlerMulti component = ((Component)OwnUnit.data).GetComponent<HoldingHandlerMulti>();
			if (Object.op_Implicit((Object)(object)OwnUnit.data.weaponHandler))
			{
				if (Object.op_Implicit((Object)(object)OwnUnit.data.weaponHandler.rightWeapon))
				{
					Weapons.Add(OwnUnit.data.weaponHandler.rightWeapon.rigidbody);
				}
				if (Object.op_Implicit((Object)(object)OwnUnit.data.weaponHandler.leftWeapon))
				{
					Weapons.Add(OwnUnit.data.weaponHandler.leftWeapon.rigidbody);
				}
			}
			else if (Object.op_Implicit((Object)(object)component))
			{
				Weapons.AddRange(component.spawnedWeapons.Select((GameObject x) => x.GetComponent<Rigidbody>()));
			}
			TrueDelay = Mathf.Clamp(unPetrifyDelay - OwnUnit.data.maxHealth / 250f + 0.4f, 1f, unPetrifyDelay);
			((MonoBehaviour)this).StartCoroutine(DoPetrifying());
		}

		public override void Ping()
		{
			pingEvent.Invoke();
		}

		private IEnumerator DoPetrifying()
		{
			if (OwnUnit.data.Dead || OwnUnit.data.healthHandler.willBeRewived)
			{
				yield break;
			}
			petrifyEvent.Invoke();
			float t = 0f;
			while (t < 1f && !OwnUnit.data.Dead)
			{
				t += Time.deltaTime * petrifySpeed;
				for (int i = 0; i < AllRigs.AllDrags.Length; i++)
				{
					AllRigs.AllDrags[i].x = OriginalDrags[i].x + t;
					AllRigs.AllDrags[i].y = OriginalDrags[i].y + t;
				}
				DragHandler.UpdateDrag();
				ColorHandler.SetColor(petrifyColor, t);
				yield return null;
			}
			if (OwnUnit.data.Dead)
			{
				ResetUnit();
				yield break;
			}
			OriginalDrags = AllRigs.AllDrags.ToList();
			OwnUnit.WeaponHandler.StopAttacksFor(TrueDelay);
			Rigidbody[] allRigs = AllRigs.AllRigs;
			for (int j = 0; j < allRigs.Length; j++)
			{
				allRigs[j].isKinematic = true;
			}
			foreach (Rigidbody weapon in Weapons)
			{
				weapon.isKinematic = true;
			}
			((MonoBehaviour)this).StartCoroutine(DoUnPetrifying());
		}

		private IEnumerator DoUnPetrifying()
		{
			yield return (object)new WaitForSeconds(TrueDelay);
			if (OwnUnit.data.Dead)
			{
				yield break;
			}
			unPetrifyEvent.Invoke();
			Rigidbody[] allRigs = AllRigs.AllRigs;
			for (int i = 0; i < allRigs.Length; i++)
			{
				allRigs[i].isKinematic = false;
			}
			foreach (Rigidbody weapon in Weapons)
			{
				weapon.isKinematic = false;
			}
			float t = 0f;
			while (t < 1f && !OwnUnit.data.Dead)
			{
				t += Time.deltaTime * unPetrifySpeed;
				for (int j = 0; j < AllRigs.AllDrags.Length; j++)
				{
					AllRigs.AllDrags[j].x = OriginalDrags[j].x - t;
					AllRigs.AllDrags[j].y = OriginalDrags[j].y - t;
				}
				DragHandler.UpdateDrag();
				ColorHandler.SetColor(petrifyColor, 1f - t);
				yield return null;
			}
		}

		private void ResetUnit()
		{
			ColorHandler.SetColor(petrifyColor, 0f);
			for (int i = 0; i < AllRigs.AllDrags.Length; i++)
			{
				AllRigs.AllDrags[i].x = OwnUnit.data.allRigs.defaultDrags[i].x;
				AllRigs.AllDrags[i].y = OwnUnit.data.allRigs.defaultDrags[i].y;
			}
		}
	}
	public class EmperorPoofEffect : MonoBehaviour
	{
		public enum UnitTarget
		{
			Furthest,
			Closest
		}

		public UnitTarget unitTarget;

		public bool automatic = true;

		public float moveDelay = 0.05f;

		public float distanceFromUnit = 2f;

		public float distanceAboveUnit = 1.5f;

		public bool useRandom = true;

		public bool meshparticle = true;

		[Tooltip("Enable for units that have erratic movement after teleporting in a ProjectMars game.")]
		public bool setUnitMainRigKinematic;

		public UnityEvent poofEvent;

		private TeamSystem MTeamSystem;

		private Unit Unit;

		private ShapeModule Emiss;

		private ParticleSystem Part;

		private List<PhysicsFollowBodyPart> Followers;

		private float CurrentDistance;

		private CanDoUnitEvents CanDo;

		private bool Done;

		private float Counter;

		private void Start()
		{
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			Unit = ((Component)this).GetComponentInParent<Unit>();
			MTeamSystem = World.Active.GetOrCreateManager<TeamSystem>();
			CanDo = ((Component)this).GetComponent<CanDoUnitEvents>();
			Counter = Random.Range(0f, 0.5f);
			if (meshparticle)
			{
				Part = ((Component)this).GetComponentInChildren<ParticleSystem>();
				Emiss = Part.shape;
				((ShapeModule)(ref Emiss)).skinnedMeshRenderer = ((Component)((Component)this).transform.root).GetComponentInChildren<SkinnedMeshRenderer>();
			}
			if (setUnitMainRigKinematic && BoltNetwork.IsClient)
			{
				Unit.data.mainRig.isKinematic = true;
			}
		}

		private void Update()
		{
			if (automatic && CanDo.canDoStuff && !Done)
			{
				Counter += Time.deltaTime;
				if (Counter > 1f)
				{
					Done = true;
					((MonoBehaviour)this).StartCoroutine(DoPoof());
				}
			}
		}

		private IEnumerator DoPoof()
		{
			if (Object.op_Implicit((Object)(object)Part))
			{
				Part.Emit(25);
			}
			yield return (object)new WaitForSeconds(moveDelay);
			List<Unit> obj = (((int)Unit.Team == 1) ? MTeamSystem.GetTeamUnits((Team)0) : MTeamSystem.GetTeamUnits((Team)1));
			Unit val = null;
			foreach (Unit item in obj)
			{
				float num = Vector3.Distance(((Component)this).transform.position, item.data.mainRig.position);
				if (Object.op_Implicit((Object)(object)val))
				{
					if (!(Random.value <= 0.2f) && useRandom)
					{
						continue;
					}
					switch (unitTarget)
					{
					case UnitTarget.Furthest:
						if (num > CurrentDistance)
						{
							CurrentDistance = num;
							val = item;
						}
						break;
					case UnitTarget.Closest:
						if (num < CurrentDistance)
						{
							CurrentDistance = num;
							val = item;
						}
						break;
					}
				}
				else
				{
					CurrentDistance = num;
					val = item;
				}
			}
			if (Object.op_Implicit((Object)(object)val))
			{
				Vector3 val2 = ((Component)val.data.mainRig).transform.position - Unit.data.mainRig.position;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				val2 = ((Component)val.data.mainRig).transform.position - Unit.data.mainRig.position;
				Vector3 val3 = normalized * (((Vector3)(ref val2)).magnitude + distanceFromUnit);
				Debug.DrawLine(((Component)this).transform.position, ((Component)val.data.mainRig).transform.position, Color.blue, 1.5f);
				DataHandler componentInChildren = ((Component)((Component)this).transform.root).GetComponentInChildren<DataHandler>();
				for (int i = 0; i < ((Component)componentInChildren).transform.childCount; i++)
				{
					Transform child = ((Component)componentInChildren).transform.GetChild(i);
					child.position += val3 + Vector3.up * distanceAboveUnit;
					if (unitTarget == UnitTarget.Furthest)
					{
						child.Rotate(Vector3.up * 180f);
					}
				}
				WeaponHandler component = ((Component)componentInChildren).GetComponent<WeaponHandler>();
				if (Object.op_Implicit((Object)(object)component))
				{
					if (Object.op_Implicit((Object)(object)component.rightWeapon))
					{
						Transform transform = ((Component)component.rightWeapon).transform;
						transform.position += val3 + Vector3.up * distanceAboveUnit;
					}
					if (Object.op_Implicit((Object)(object)component.leftWeapon))
					{
						Transform transform2 = ((Component)component.leftWeapon).transform;
						transform2.position += val3 + Vector3.up * distanceAboveUnit;
					}
				}
				Followers = new List<PhysicsFollowBodyPart>();
				Followers.AddRange(((Component)((Component)this).transform.root).GetComponentsInChildren<PhysicsFollowBodyPart>());
				foreach (PhysicsFollowBodyPart follower in Followers)
				{
					Transform transform3 = ((Component)follower).transform;
					transform3.position += val3 + Vector3.up * distanceAboveUnit;
				}
			}
			UnityEvent obj2 = poofEvent;
			if (obj2 != null)
			{
				obj2.Invoke();
			}
			if (Object.op_Implicit((Object)(object)Part))
			{
				Part.Play();
			}
		}

		public void DoThePoof()
		{
			((MonoBehaviour)this).StartCoroutine(DoPoof());
		}
	}
	public class HadesEgg : MonoBehaviour
	{
		[HideInInspector]
		public bool hasHatched;

		public UnityEvent hatchEvent = new UnityEvent();

		public ParticleSystem souls;

		public float particleMultiplier = 0.05f;

		public float currentHealth;

		public float requiredHealth = 777f;

		[HideInInspector]
		public List<Unit> hitList = new List<Unit>();

		public void AddHealth(float amount)
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			if (!hasHatched)
			{
				currentHealth += amount;
				EmissionModule emission = souls.emission;
				if (currentHealth >= requiredHealth)
				{
					((EmissionModule)(ref emission)).rateOverTime = MinMaxCurve.op_Implicit(requiredHealth * particleMultiplier);
					HatchEgg();
				}
				else
				{
					MinMaxCurve rateOverTime = ((EmissionModule)(ref emission)).rateOverTime;
					((EmissionModule)(ref emission)).rateOverTime = MinMaxCurve.op_Implicit(((MinMaxCurve)(ref rateOverTime)).constant + amount * particleMultiplier);
				}
			}
		}

		public void HatchEgg()
		{
			hatchEvent.Invoke();
			hasHatched = true;
		}
	}
	public class HadesSpawnObjects : MonoBehaviour
	{
		private TeamHolder TeamHolder;

		public List<GameObject> objectsToSpawn = new List<GameObject>();

		public int amountToSpawn = 10;

		public float radius = 8f;

		public float delayPerSpawn = 0.08f;

		public bool spawnOnStart = true;

		public void Start()
		{
			TeamHolder = ((Component)this).GetComponentInParent<TeamHolder>() ?? ((Component)this).gameObject.AddComponent<TeamHolder>();
			if (spawnOnStart)
			{
				SpawnObjects();
			}
		}

		public void SpawnObjects()
		{
			((MonoBehaviour)this).StartCoroutine(DoSpawning());
		}

		public IEnumerator DoSpawning()
		{
			Vector3 val = default(Vector3);
			for (int i = 0; i < amountToSpawn; i++)
			{
				((Vector3)(ref val))..ctor(((Component)this).transform.position.x + Random.Range(0f - radius, radius), ((Component)this).transform.position.y + 2f, ((Component)this).transform.position.z + Random.Range(0f - radius, radius));
				TeamHolder obj = Object.Instantiate<GameObject>(objectsToSpawn[Random.Range(0, objectsToSpawn.Count)], val, Quaternion.LookRotation(Vector3.up)).AddComponent<TeamHolder>();
				obj.team = TeamHolder.team;
				obj.spawner = TeamHolder.spawner;
				yield return (object)new WaitForSeconds(delayPerSpawn);
			}
		}
	}
	public class HadesTotem : MonoBehaviour
	{
		private TeamHolder TeamHolder;

		private HadesEgg Egg;

		public UnityEvent drainEvent = new UnityEvent();

		public GameObject objectToSpawn;

		public float radius = 4f;

		public float delayPerDrain = 0.05f;

		public float healthToDrain = 150f;

		public int limitPerDrain = 3;

		public bool addToHitList;

		private void Start()
		{
			TeamHolder = ((Component)this).GetComponentInParent<TeamHolder>();
			Egg = TeamHolder.spawner.GetComponentInChildren<HadesEgg>();
		}

		public void Drain()
		{
			((MonoBehaviour)this).StartCoroutine(DoDrain());
		}

		public IEnumerator DoDrain()
		{
			Unit[] targets = SetTargets();
			if (targets.Length == 0)
			{
				yield break;
			}
			int limit = Mathf.Min(targets.Length, limitPerDrain);
			for (int i = 0; i < limit; i++)
			{
				GameObject obj = Object.Instantiate<GameObject>(objectToSpawn, ((Component)this).transform.position, ((Component)this).transform.rotation);
				TeamHolder.AddTeamHolder(obj, (Unit)null, TeamHolder);
				TargetableEffect[] components = obj.GetComponents<TargetableEffect>();
				foreach (TargetableEffect obj2 in components)
				{
					obj2.DoEffect(((Component)this).transform, ((Component)targets[i].data.mainRig).transform);
					obj2.DoEffect(((Component)this).transform.position, targets[i].data.mainRig.position, targets[i].data.mainRig);
				}
				Egg.AddHealth(healthToDrain);
				if (addToHitList)
				{
					Egg.hitList.Add(targets[i]);
				}
				drainEvent.Invoke();
				((MonoBehaviour)this).StartCoroutine(RemoveUnitFromList(targets[i]));
				yield return (object)new WaitForSeconds(delayPerDrain);
			}
			if (!Egg.hasHatched)
			{
				GameObject obj3 = Object.Instantiate<GameObject>(objectToSpawn, ((Component)this).transform.position, ((Component)this).transform.rotation);
				TeamHolder.AddTeamHolder(obj3, (Unit)null, TeamHolder);
				Object.Destroy((Object)(object)obj3.GetComponent<AddTargetableEffect>());
				TargetableEffect[] components = obj3.GetComponents<TargetableEffect>();
				for (int j = 0; j < components.Length; j++)
				{
					components[j].DoEffect(((Component)this).transform, ((Component)Egg).transform);
				}
			}
		}

		public Unit[] SetTargets()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return (from hit in Physics.SphereCastAll(((Component)this).transform.position, radius, Vector3.up, 0.1f, LayerMask.GetMask(new string[1] { "MainRig" }))
				select ((Component)((RaycastHit)(ref hit)).transform.root).GetComponent<Unit>() into x
				where Object.op_Implicit((Object)(object)((Component)this).GetComponentInParent<TeamHolder>()) && Object.op_Implicit((Object)(object)x) && !x.data.Dead && x.Team != ((Component)this).GetComponentInParent<TeamHolder>().team && !Egg.hitList.Contains(x)
				select x).OrderBy(delegate(Unit x)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				Vector3 val = ((Component)x.data.mainRig).transform.position - ((Component)this).transform.position;
				return ((Vector3)(ref val)).magnitude;
			}).Distinct().ToArray();
		}

		public IEnumerator RemoveUnitFromList(Unit unit)
		{
			yield return (object)new WaitForSeconds(1f);
			if (Object.op_Implicit((Object)(object)unit))
			{
				Egg.hitList.Remove(unit);
			}
		}
	}
	public class HammerBounceRig : MonoBehaviour
	{
		private float Counter;

		private Rigidbody OwnRig;

		private Unit Target;

		private Unit OwnUnit;

		private List<Unit> HitList = new List<Unit>();

		private int HitCount;

		private bool Finished;

		[Header("Projectile Settings")]
		public int hitLimit = 10;

		public float maxRange = 50f;

		public float flightSpeed = 1f;

		public float rotationSpeed = 30f;

		[Header("Return Settings")]
		public float returnSpeed = 0.5f;

		public string objectToReturnTo;

		private bool Returning;

		private float ReturnCounter;

		private Transform ReturnObject;

		private Weapon Weapon;

		private Vector3 ReturnPosition;

		private Quaternion ReturnRotation;

		public UnityEvent finishEvent = new UnityEvent();

		[Header("Damage Settings")]
		public float cooldown = 0.01f;

		public float damage;

		public float impactMultiplier = 1f;

		public float impactForce;

		public float impactScreenShake = 1f;

		public float massCap;

		public void Start()
		{
			OwnRig = ((Component)this).GetComponent<Rigidbody>();
			OwnUnit = ((Component)((Component)this).transform.root).GetComponent<Unit>();
			Weapon = (Object.op_Implicit((Object)(object)((Component)((Component)this).transform).GetComponentInParent<Weapon>()) ? ((Component)((Component)this).transform).GetComponentInParent<Weapon>() : ((Component)((Component)this).transform.root).GetComponent<Unit>().WeaponHandler.rightWeapon);
			ReturnObject = TransformExtensions.FindChildRecursive(((Component)Weapon).transform, objectToReturnTo);
			SetTarget(100f);
		}

		public void Update()
		{
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Unknown result type (might be due to invalid IL or missing references)
			//IL_0142: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			Counter += Time.deltaTime;
			if (!Object.op_Implicit((Object)(object)Target) && !Returning)
			{
				SetTarget();
			}
			else if (Object.op_Implicit((Object)(object)Target))
			{
				Vector3 val = Target.data.mainRig.position - ((Component)this).transform.position;
				OwnRig.AddForce(((Vector3)(ref val)).normalized * (flightSpeed * OwnRig.mass * Time.deltaTime));
				OwnRig.MoveRotation(Quaternion.LookRotation(Vector3.RotateTowards(((Component)this).transform.forward, val, Time.deltaTime * rotationSpeed, 0f)));
			}
			if (Returning)
			{
				if (ReturnCounter >= 1f)
				{
					((Component)Weapon).GetComponent<DelayEvent>().Go();
					Object.Destroy((Object)(object)((Component)this).gameObject);
					Returning = false;
				}
				else
				{
					((Component)this).transform.position = Vector3.Lerp(ReturnPosition, ReturnObject.position, ReturnCounter);
					((Component)this).transform.rotation = Quaternion.Lerp(ReturnRotation, ReturnObject.rotation, ReturnCounter);
					ReturnCounter += Time.deltaTime * returnSpeed;
				}
			}
		}

		public void OnCollisionEnter(Collision col)
		{
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_016c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0140: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
			Unit component = ((Component)col.transform.root).GetComponent<Unit>();
			if (!(Counter < cooldown) && Object.op_Implicit((Object)(object)component) && Object.op_Implicit((Object)(object)col.rigidbody) && (!Object.op_Implicit((Object)(object)component) || !HitList.Contains(component)) && (!Object.op_Implicit((Object)(object)component) || component.Team != ((Component)this).GetComponent<TeamHolder>().team))
			{
				Counter = 0f;
				bool flag = col.transform.IsChildOf(((Component)component.data).transform);
				((Damagable)component.data.healthHandler).TakeDamage(damage * (flag ? 1f : 0f), Vector3.zero, (Unit)null, (DamageType)0);
				Vector3 impulse = col.impulse;
				float num = Mathf.Clamp(((Vector3)(ref impulse)).magnitude / (OwnRig.mass + 10f) * 0.3f * impactMultiplier, 0f, 2f);
				if (Object.op_Implicit((Object)(object)ScreenShake.Instance))
				{
					ScreenShake.Instance.AddForce(((Component)this).transform.forward * Mathf.Sqrt(num * 0.5f) * 0.5f * impactScreenShake, ((ContactPoint)(ref col.contacts[0])).point);
				}
				WilhelmPhysicsFunctions.AddForceWithMinWeight(component.data.mainRig, Mathf.Sqrt(num * 50f) * ((Component)this).transform.forward * impactForce * (flag ? 1f : 0f), (ForceMode)1, massCap);
				WilhelmPhysicsFunctions.AddForceWithMinWeight(col.rigidbody, Mathf.Sqrt(num * 50f) * ((Component)this).transform.forward * impactForce, (ForceMode)1, massCap);
				CollisionWeaponEffect[] components = ((Component)this).GetComponents<CollisionWeaponEffect>();
				for (int i = 0; i < components.Length; i++)
				{
					components[i].DoEffect(col.transform, col);
				}
				if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<CollisionSound>()))
				{
					((Component)this).GetComponent<CollisionSound>().DoEffect(col.transform, col, num);
				}
				HitCount += ((!((Object)col.transform).name.Contains("Mjolnir")) ? 1 : hitLimit);
				HitList.Add(component);
				SetTarget();
				if (HitCount >= hitLimit)
				{
					Finish();
				}
			}
		}

		public void SetTarget(float radius = 0f)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			Unit[] array = (from hit in Physics.SphereCastAll(((Component)this).transform.position, (radius != 0f) ? radius : maxRange, Vector3.up, 0.1f, LayerMask.GetMask(new string[1] { "MainRig" }))
				select ((Component)((RaycastHit)(ref hit)).transform.root).GetComponent<Unit>() into x
				where Object.op_Implicit((Object)(object)x) && !x.data.Dead && x.Team != OwnUnit.Team && !HitList.Contains(x)
				select x).OrderBy(delegate(Unit x)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				Vector3 val = ((Component)x.data.mainRig).transform.position - ((Component)this).transform.position;
				return ((Vector3)(ref val)).magnitude;
			}).Distinct().ToArray();
			if (array.Length != 0)
			{
				Target = array[0];
			}
			else
			{
				Finish();
			}
		}

		public void Return()
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			Returning = true;
			ReturnPosition = ((Component)this).transform.position;
			ReturnRotation = ((Component)this).transform.rotation;
		}

		public void Finish()
		{
			if (!Finished)
			{
				finishEvent.Invoke();
				Finished = true;
			}
		}
	}
	public static class HUAddons
	{
		public static object GetField(Type type, object instance, string fieldName)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			return type.GetField(fieldName, bindingAttr).GetValue(instance);
		}

		public static void SetField<T>(object originalObject, string fieldName, T newValue)
		{
			BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic;
			originalObject.GetType().GetField(fieldName, bindingAttr).SetValue(originalObject, newValue);
		}

		public static string DeepString(this GameObject self)
		{
			string text = "\nGameObject '" + ((Object)self).name + "':\n{\n\tComponents:\n\t{\n";
			text = string.Concat(text, string.Concat(from Component component in self.GetComponents<Component>()
				select "\t\t" + ((object)component).GetType().Name + "\n"));
			text += "\t}\n";
			if (self.transform.childCount > 0)
			{
				text += "\tChildren:\n\t{\n";
				text = string.Concat(text, string.Concat(from Transform child in (IEnumerable)self.transform
					select ((Component)child).gameObject.DeepString().Replace("\n", "\n\t\t")));
				text += "\n\t}\n";
			}
			return text + "}\n";
		}

		public static T DeepCopyOf<T>(this T self, T from) where T : class
		{
			FieldInfo[] fields = typeof(T).GetFields((BindingFlags)(-1));
			foreach (FieldInfo fieldInfo in fields)
			{
				try
				{
					fieldInfo.SetValue(self, fieldInfo.GetValue(from));
				}
				catch
				{
				}
			}
			PropertyInfo[] properties = typeof(T).GetProperties((BindingFlags)(-1));
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (propertyInfo.CanWrite && propertyInfo.CanRead)
				{
					try
					{
						propertyInfo.SetValue(self, propertyInfo.GetValue(from));
					}
					catch
					{
					}
				}
			}
			return self;
		}
	}
	public class HUChangeLayerOfRigibodies : MonoBehaviour
	{
		public bool includeWeapons = true;

		private RigidbodyHolder RigHolder;

		private List<Rigidbody> Rigs;

		private List<int> Layers;

		private List<int> ColliderLayers;

		private Collider[] Colliders;

		private WeaponHandler WeaponHandler;

		private void Start()
		{
			RigHolder = ((Component)((Component)this).transform.root).GetComponentInChildren<RigidbodyHolder>();
			Rigs = new List<Rigidbody>();
			Layers = new List<int>();
			ColliderLayers = new List<int>();
			Rigs.AddRange(RigHolder.AllRigs);
			Colliders = ((Component)((Component)((Component)((Component)this).transform.root).GetComponentInChildren<DataHandler>()).transform).GetComponentsInChildren<Collider>();
			WeaponHandler = ((Component)((Component)this).transform.root).GetComponentInChildren<WeaponHandler>();
			if (Object.op_Implicit((Object)(object)WeaponHandler) && includeWeapons)
			{
				if (Object.op_Implicit((Object)(object)WeaponHandler.rightWeapon))
				{
					Rigs.Add(WeaponHandler.rightWeapon.rigidbody);
				}
				if (Object.op_Implicit((Object)(object)WeaponHandler.leftWeapon))
				{
					Rigs.Add(WeaponHandler.leftWeapon.rigidbody);
				}
			}
		}

		public void ChangeLayer()
		{
			for (int i = 0; i < Rigs.Count; i++)
			{
				if (Object.op_Implicit((Object)(object)Rigs[i]))
				{
					Layers.Add(((Component)Rigs[i]).gameObject.layer);
					((Component)Rigs[i]).gameObject.layer = 20;
				}
			}
			for (int j = 0; j < Colliders.Length; j++)
			{
				if (Object.op_Implicit((Object)(object)Colliders[j]))
				{
					ColliderLayers.Add(((Component)Colliders[j]).gameObject.layer);
					((Component)Colliders[j]).gameObject.layer = 20;
				}
			}
		}

		public void ResetLayer()
		{
			for (int i = 0; i < Rigs.Count; i++)
			{
				if (Object.op_Implicit((Object)(object)Rigs[i]))
				{
					((Component)Rigs[i]).gameObject.layer = Layers[i];
				}
			}
			for (int j = 0; j < Colliders.Length; j++)
			{
				if (Object.op_Implicit((Object)(object)Colliders[j]))
				{
					((Component)Colliders[j]).gameObject.layer = ColliderLayers[j];
				}
			}
		}
	}
	[BepInPlugin("teamgrad.hiddenunits", "Hidden Units", "1.3.0")]
	[BepInDependency(/*Could not decode attribute arguments.*/)]
	public class HULauncher : TGMod
	{
		public static ConfigEntry<bool> configInfiniteScalingEnabled;

		public override void Launch()
		{
			new HUMain();
		}

		public override void AddSettings()
		{
			configInfiniteScalingEnabled = ((BaseUnityPlugin)this).Config.Bind<bool>("Bug", "InfiniteScalingEnabled", true, "Enables/disables Mathematician/Philosopher projectiles infinitely scaling unit parts.");
			TGAddons.CreateSetting((SettingsType)0, "Toggle infinite projectile scaling", "Enables/disables Mathematician/Philosopher projectiles infinitely scaling unit parts.", "BUG", 0f, (float)((!configInfiniteScalingEnabled.Value) ? 1 : 0), new string[2] { "Disabled", "Enabled" }, 0f, 1f).OnValueChanged += delegate(int value)
			{
				configInfiniteScalingEnabled.Value = value == 1;
			};
		}

		public override void SceneManager(Scene scene, LoadSceneMode laodSceneMode)
		{
			//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0409: Expected O, but got Unknown
			//IL_043d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0442: Unknown result type (might be due to invalid IL or missing references)
			//IL_044f: Expected O, but got Unknown
			//IL_054b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0550: Unknown result type (might be due to invalid IL or missing references)
			//IL_055d: Expected O, but got Unknown
			//IL_058e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0593: Unknown result type (might be due to invalid IL or missing references)
			//IL_05a0: Expected O, but got Unknown
			//IL_0602: Unknown result type (might be due to invalid IL or missing references)
			//IL_0607: Unknown result type (might be due to invalid IL or missing references)
			//IL_0614: Expected O, but got Unknown
			//IL_0662: Unknown result type (might be due to invalid IL or missing references)
			//IL_0667: Unknown result type (might be due to invalid IL or missing references)
			//IL_0674: Expected O, but got Unknown
			//IL_0383: Unknown result type (might be due to invalid IL or missing references)
			//IL_0388: Unknown result type (might be due to invalid IL or missing references)
			//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_06a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_06ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_06ba: Expected O, but got Unknown
			//IL_075f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0764: Unknown result type (might be due to invalid IL or missing references)
			//IL_0771: Expected O, but got Unknown
			//IL_07a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_07b4: Expected O, but got Unknown
			//IL_0822: Unknown result type (might be due to invalid IL or missing references)
			//IL_0827: Unknown result type (might be due to invalid IL or missing references)
			//IL_0834: Expected O, but got Unknown
			//IL_08bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_08c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_08ce: Expected O, but got Unknown
			//IL_0939: Unknown result type (might be due to invalid IL or missing references)
			//IL_093e: Unknown result type (might be due to invalid IL or missing references)
			//IL_094b: Expected O, but got Unknown
			//IL_09b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_09bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_09c8: Expected O, but got Unknown
			//IL_0a16: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a1b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a28: Expected O, but got Unknown
			//IL_0a93: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a98: Unknown result type (might be due to invalid IL or missing references)
			//IL_0aa5: Expected O, but got Unknown
			//IL_0aea: Unknown result type (might be due to invalid IL or missing references)
			//IL_0aef: Unknown result type (might be due to invalid IL or missing references)
			//IL_0afc: Expected O, but got Unknown
			//IL_0b30: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b35: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b42: Expected O, but got Unknown
			//IL_0bca: Unknown result type (might be due to invalid IL or missing references)
			//IL_0bcf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0bdc: Expected O, but got Unknown
			//IL_0c5e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c63: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c70: Expected O, but got Unknown
			if (((Scene)(ref scene)).path == "Assets/11 Scenes/MainMenu.unity")
			{
				if (!ServiceLocator.GetService<ISaveLoaderService>().HasUnlockedSecret("SECRET_EGYPT"))
				{
					ServiceLocator.GetService<ISaveLoaderService>().UnlockSecret("SECRET_EGYPT");
					ServiceLocator.GetService<ModalPanel>().OpenUnlockPanel("You unlocked the Egypt faction!", HUMain.hiddenUnits.LoadAsset<Sprite>("egypt"));
				}
			}
			else if (((Scene)(ref scene)).name.Contains("SG_"))
			{
				if (((Scene)(ref scene)).name == "SG_Egypt" && ServiceLocator.GetService<ISaveLoaderService>().HasUnlockedSecret("BILLY_SWORD"))
				{
					Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("BillyKey_Unlock4"), (Transform)null, true);
				}
				GameObject val = null;
				GameObject val2 = null;
				GameObject[] rootGameObjects = ((Scene)(ref scene)).GetRootGameObjects();
				foreach (GameObject val3 in rootGameObjects)
				{
					if (((Object)val3).name == "AStar_Lvl1_Grid")
					{
						val = val3;
					}
					if (((Object)val3).name == "Map")
					{
						val2 = val3;
						foreach (MeshRenderer item in new List<MeshRenderer>(val3.GetComponentsInChildren<MeshRenderer>(true).ToList().FindAll((MeshRenderer x) => ((Object)x).name.Contains("_ReplaceMe"))))
						{
							((Renderer)item).material.shader = Shader.Find(((Object)((Renderer)item).material.shader).name) ?? ((Renderer)item).material.shader;
							if (Object.op_Implicit((Object)(object)((Component)item).GetComponent<PiratePlacementTransparency>()))
							{
								((Component)item).GetComponent<PiratePlacementTransparency>().Materials[0].m_oldMaterial.shader = Shader.Find(((Object)((Component)item).GetComponent<PiratePlacementTransparency>().Materials[0].m_oldMaterial.shader).name) ?? ((Component)item).GetComponent<PiratePlacementTransparency>().Materials[0].m_oldMaterial.shader;
							}
						}
					}
					if (((Object)val3).name.Contains("_ReplaceMe"))
					{
						((Renderer)val3.GetComponent<MeshRenderer>()).material.shader = Shader.Find(((Object)((Renderer)val3.GetComponent<MeshRenderer>()).material.shader).name) ?? Shader.Find(((Object)((Renderer)val3.GetComponent<MeshRenderer>()).material.shader).name);
					}
					if (((Object)val3).name == "WaterManager")
					{
						val3.GetComponent<PirateWaterManager>().WaterMaterial = ((Renderer)val3.GetComponent<MeshRenderer>()).material;
					}
				}
				if ((Object)(object)val != (Object)null && (Object)(object)val2 != (Object)null)
				{
					AstarPath componentInChildren = val.GetComponentInChildren<AstarPath>(true);
					val.SetActive(true);
					if (componentInChildren.data.graphs.Length != 0)
					{
						componentInChildren.data.RemoveGraph(componentInChildren.data.graphs[0]);
					}
					componentInChildren.data.AddGraph(typeof(RecastGraph));
					componentInChildren.data.recastGraph.minRegionSize = 0.1f;
					componentInChildren.data.recastGraph.characterRadius = 0.3f;
					componentInChildren.data.recastGraph.cellSize = 0.2f;
					((NavmeshBase)componentInChildren.data.recastGraph).forcedBoundsSize = new Vector3(val2.GetComponent<MapSettings>().m_mapRadius * 2f, val2.GetComponent<MapSettings>().m_mapRadius * val2.GetComponent<MapSettings>().mapRadiusYMultiplier * 2f, val2.GetComponent<MapSettings>().m_mapRadius * 2f);
					componentInChildren.data.recastGraph.rasterizeMeshes = false;
					componentInChildren.data.recastGraph.rasterizeColliders = true;
					componentInChildren.data.recastGraph.mask = HUMain.hiddenUnits.LoadAsset<GameObject>("AStarDummy").GetComponent<Explosion>().layerMask;
					componentInChildren.Scan((NavGraph[])null);
				}
			}
			else if (((Scene)(ref scene)).name == "00_Simulation_Day_VC")
			{
				GameObject val4 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Saitama_Unlock"), val4.transform, true);
			}
			else if (((Scene)(ref scene)).name == "00_Lvl2_Halloween_VC")
			{
				GameObject val5 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Hadez_Unlock"), val5.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("EmpSword_Unlock1"), val5.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("EmpSword_Unlock2"), val5.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("EmpSword_Unlock3"), val5.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("EmpSword_Unlock4"), val5.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("EmpSword_Unlock5"), val5.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("EmpSword_Unlock6"), val5.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("GrievingTitan_Unlock"), val5.transform, true);
			}
			else if (((Scene)(ref scene)).name == "01_Lvl1_Tribal_VC")
			{
				GameObject val6 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("WD_Unlock"), val6.transform, true);
			}
			else if (((Scene)(ref scene)).name == "01_Lvl2_Tribal_VC")
			{
				GameObject val7 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Shaman_Unlock"), val7.transform, true);
				if (ServiceLocator.GetService<ISaveLoaderService>().HasUnlockedSecret("BILLY_SWORD"))
				{
					Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("BillyKey_Unlock2"), val7.transform, true);
				}
			}
			else if (((Scene)(ref scene)).name == "01_Sandbox_Tribal_01_VC")
			{
				GameObject val8 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Gatherer_Unlock"), val8.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Clubmaster_Unlock"), val8.transform, true);
			}
			else if (((Scene)(ref scene)).name == "02_Lvl1_Farmer_VC")
			{
				GameObject val9 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Butcher_Unlock"), val9.transform, true);
			}
			else if (((Scene)(ref scene)).name == "02_Lvl2_Farmer_VC")
			{
				GameObject val10 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Chicken_Unlock1"), val10.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Chicken_Unlock2"), val10.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Chicken_Unlock3"), val10.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Chicken_Unlock4"), val10.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Chicken_Unlock5"), val10.transform, true);
			}
			else if (((Scene)(ref scene)).name == "03_Lvl1_Ancient_VC")
			{
				GameObject val11 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Helicopter_Unlock"), val11.transform, true);
			}
			else if (((Scene)(ref scene)).name == "03_Lvl2_Ancient_VC")
			{
				GameObject val12 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Mathematician_Unlock"), val12.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Philosopher_Unlock"), val12.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Apollo_Unlock"), val12.transform, true);
			}
			else if (((Scene)(ref scene)).name == "03_Sandbox_Ancient_01_VC")
			{
				GameObject val13 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("TrojanChicken_Unlock"), val13.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Ares_Unlock"), val13.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Centaur_Unlock"), val13.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("AncientTank_Unlock"), val13.transform, true);
			}
			else if (((Scene)(ref scene)).name == "04_Lvl1_Viking_VC")
			{
				GameObject val14 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Warlord_Unlock"), val14.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("TheReaver_Unlock"), val14.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("RuneMage_Unlock"), val14.transform, true);
			}
			else if (((Scene)(ref scene)).name == "04_Sandbox_Viking_VC")
			{
				GameObject val15 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("DreadKing_Unlock"), val15.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Thor_Unlock"), val15.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Odin_Unlock"), val15.transform, true);
			}
			else if (((Scene)(ref scene)).name == "05_Lvl1_Medieval_VC")
			{
				GameObject val16 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Tower_Unlock"), val16.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Thief_Unlock"), val16.transform, true);
			}
			else if (((Scene)(ref scene)).name == "05_Lvl2_Medieval_VC")
			{
				GameObject val17 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Ignislasher_Unlock"), val17.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Templar_Unlock"), val17.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Bishop_Unlock"), val17.transform, true);
			}
			else if (((Scene)(ref scene)).name == "08_Lvl1_Pirate_VC")
			{
				GameObject val18 = new GameObject
				{
					name = "Secrets"
				};
				if (ServiceLocator.GetService<ISaveLoaderService>().HasUnlockedSecret("BILLY_SWORD"))
				{
					Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("BillyKey_Unlock1"), val18.transform, true);
				}
			}
			else if (((Scene)(ref scene)).name == "09_Lvl1_Western_VC")
			{
				GameObject val19 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Prospector_Unlock"), val19.transform, true);
			}
			else if (((Scene)(ref scene)).name == "05_Sandbox_Medieval_VC")
			{
				GameObject val20 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("FlailMaster_Unlock"), val20.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("SpiderMage_Unlock"), val20.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("MayhemGunner_Unlock"), val20.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Billy_Unlock"), val20.transform, true);
			}
			else if (((Scene)(ref scene)).name == "09_Lvl1_Fantasy_Evil_VC")
			{
				GameObject val21 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("BusinessMan_Unlock"), val21.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Cthulhu_Unlock"), val21.transform, true);
				if (ServiceLocator.GetService<ISaveLoaderService>().HasUnlockedSecret("BILLY_SWORD"))
				{
					Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("BillyKey_Unlock3"), val21.transform, true);
				}
			}
			else if (((Scene)(ref scene)).name == "09_Lvl1_Fantasy_Good_VC")
			{
				GameObject val22 = new GameObject
				{
					name = "Secrets"
				};
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Aetherian_Unlock"), val22.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Angel_Unlock"), val22.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Pegasus_Unlock"), val22.transform, true);
				Object.Instantiate<GameObject>(HUMain.hiddenUnits.LoadAsset<GameObject>("Seraphim_Unlock"), val22.transform, true);
			}
		}

		public override void Localize(LocalizationHolder holder)
		{
			holder.languages.AddRange(HUMain.hiddenUnits.LoadAsset<GameObject>("Lang").GetComponent<LocalizationHolder>().languages);
		}
	}
	public class HUMain
	{
		public static AssetBundle hiddenUnits = AssetBundle.LoadFromMemory(Resources.hiddenunits);

		public static AssetBundle huMaps = AssetBundle.LoadFromMemory(Resources.humaps);

		public static bool InfiniteScalingEnabled => HULauncher.configInfiniteScalingEnabled.Value;

		public HUMain()
		{
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			AssetBundle.LoadFromMemory(Resources.egyptmap);
			AssetBundle.LoadFromMemory(Resources.egyptmap2);
			List<MapAsset> list = new List<MapAsset>();
			Dictionary<DatabaseID, int> dictionary = new Dictionary<DatabaseID, int>();
			List<MapAsset> list2 = ((MapAsset[])typeof(LandfallContentDatabase).GetField("m_orderedMapAssets", BindingFlags.Instance | BindingFlags.NonPublic)?.GetValue(TGMain.landfallDb)).ToList();
			for (int i = 0; i < 29; i++)
			{
				list.Add(list2[i]);
			}
			list.Add(huMaps.LoadAsset<MapAsset>("Egypt1"));
			list.Add(huMaps.LoadAsset<MapAsset>("Egypt2"));
			list2.RemoveRange(0, 29);
			list.AddRange(list2);
			MapAsset[] array = huMaps.LoadAllAssets<MapAsset>();
			foreach (MapAsset val in array)
			{
				if (!((Object)val).name.Contains("Egypt"))
				{
					list.Add(val);
				}
			}
			foreach (MapAsset item3 in list)
			{
				dictionary.Add(item3.Entity.GUID, list.IndexOf(item3));
			}
			typeof(LandfallContentDatabase).GetField("m_orderedMapAssets", BindingFlags.Instance | BindingFlags.NonPublic)?.SetValue(TGMain.landfallDb, list.ToArray());
			typeof(LandfallContentDatabase).GetField("m_mapAssetIndexLookup", BindingFlags.Instance | BindingFlags.NonPublic)?.SetValue(TGMain.landfallDb, dictionary);
			new Harmony("HiddenUnis").PatchAll();
			List<SecretUnlockCondition> list3 = new List<SecretUnlockCondition>(Resources.FindObjectsOfTypeAll<SecretUnlockConditions>()[0].m_unlockConditions);
			list3.AddRange(hiddenUnits.LoadAsset<SecretUnlockConditions>("HUUnlockConditions").m_unlockConditions);
			Resources.FindObjectsOfTypeAll<SecretUnlockConditions>()[0].m_unlockConditions = list3.ToArray();
			Material[] array2 = hiddenUnits.LoadAllAssets<Material>();
			foreach (Material val2 in array2)
			{
				if (Object.op_Implicit((Object)(object)Shader.Find(((Object)val2.shader).name)))
				{
					val2.shader = Shader.Find(((Object)val2.shader).name);
				}
			}
			foreach (UnitBlueprint unit2 in from x in hiddenUnits.LoadAllAssets<UnitBlueprint>()
				where (Object)(object)x.UnitBase != (Object)null
				select x)
			{
				foreach (GameObject item4 in from unitBase in TGMain.landfallDb.GetUnitBases().ToList()
					where ((Object)unitBase).name == ((Object)unit2.UnitBase).name
					select unitBase)
				{
					unit2.UnitBase = item4;
				}
				foreach (GameObject item5 in TGMain.landfallDb.GetWeapons().ToList())
				{
					if (Object.op_Implicit((Object)(object)unit2.RightWeapon) && ((Object)item5).name == ((Object)unit2.RightWeapon).name)
					{
						unit2.RightWeapon = item5;
					}
					if (Object.op_Implicit((Object)(object)unit2.LeftWeapon) && ((Object)item5).name == ((Object)unit2.LeftWeapon).name)
					{
						unit2.LeftWeapon = item5;
					}
				}
			}
			Faction[] array3 = hiddenUnits.LoadAllAssets<Faction>();
			foreach (Faction val3 in array3)
			{
				UnitBlueprint[] source = (from x in val3.Units
					where Object.op_Implicit((Object)(object)x)
					orderby x.GetUnitCost(true)
					select x).ToArray();
				val3.Units = source.ToArray();
				foreach (Faction item6 in TGMain.landfallDb.GetFactions().ToList())
				{
					if (val3.Entity.Name == item6.Entity.Name + "_NEW")
					{
						List<UnitBlueprint> list4 = new List<UnitBlueprint>(item6.Units);
						list4.AddRange(val3.Units);
						item6.Units = (from x in list4
							where Object.op_Implicit((Object)(object)x)
							orderby x.GetUnitCost(true)
							select x).ToArray();
						Object.DestroyImmediate((Object)(object)val3);
					}
				}
			}
			TABSCampaignLevelAsset[] array4 = hiddenUnits.LoadAllAssets<TABSCampaignLevelAsset>();
			foreach (TABSCampaignLevelAsset lvl in array4)
			{
				Faction val4 = hiddenUnits.LoadAllAssets<Faction>().ToList().Find((Faction x) => ((Object)x).name.Contains("Egypt"));
				Faction val5 = TGMain.landfallDb.GetFactions().ToList().Find((Faction x) => ((Object)x).name.Contains("Secret"));
				List<UnitBlueprint> list5 = new List<UnitBlueprint>();
				List<Faction> list6 = new List<Faction>();
				if (((Object)lvl).name.Contains("EgyptLevel"))
				{
					list6.AddRange(from x in TGMain.landfallDb.GetFactions().ToList()
						where x.m_displayFaction
						select x);
					list6.Remove(val5);
				}
				else if (((Object)lvl).name.Contains("EgyptMiscLevel"))
				{
					list6.Add(val4);
					list6.Add(val5);
					list5.AddRange(val4.Units);
					list5.Add(val5.Units.ToList().Find((UnitBlueprint x) => ((Object)x).name.Contains("BoomerangThrower")));
					list5.Add(val5.Units.ToList().Find((UnitBlueprint x) => ((Object)x).name.Contains("PotThrower")));
					list5.Add(val5.Units.ToList().Find((UnitBlueprint x) => ((Object)x).name.Contains("Sarcophagus")));
					list5.Add(val5.Units.ToList().Find((UnitBlueprint x) => ((Object)x).name.Contains("Selket")));
					list5.Add(val5.Units.ToList().Find((UnitBlueprint x) => ((Object)x).name.Contains("RaWarrior")));
				}
				if (((Object)lvl).name.Contains("MapEquals"))
				{
					MapAsset val6 = TGMain.landfallDb.GetMapAssetsOrdered().ToList().Find((MapAsset x) => ((Object)x).name.Contains(((Object)lvl).name.Split(new string[1] { "MapEquals_" }, StringSplitOptions.RemoveEmptyEntries).Last()));
					if (Object.op_Implicit((Object)(object)val6))
					{
						lvl.MapAsset = val6;
					}
				}
				List<TABSLayoutUnit> list7 = new List<TABSLayoutUnit>();
				list7.AddRange(lvl.BlueUnits);
				list7.AddRange(lvl.RedUnits);
				foreach (TABSLayoutUnit unit in list7)
				{
					if (Object.op_Implicit((Object)(object)unit.m_unitBlueprint) && ((Object)unit.m_unitBlueprint).name.Contains("_VANILLA"))
					{
						UnitBlueprint val7 = TGMain.landfallDb.GetUnitBlueprints().ToList().Find((UnitBlueprint x) => ((Object)x).name == ((Object)unit.m_unitBlueprint).name.Replace("_VANILLA", ""));
						if (Object.op_Implicit((Object)(object)val7))
						{
							unit.m_unitBlueprint = val7;
						}
					}
				}
				lvl.AllowedFactions = list6.ToArray();
				lvl.AllowedUnits = list5.ToArray();
			}
			foreach (PropItem item7 in from x in hiddenUnits.LoadAllAssets<GameObject>()
				where Object.op_Implicit((Object)(object)x.GetComponent<PropItem>())
				select x.GetComponent<PropItem>())
			{
				if (!Object.op_Implicit((Object)(object)item7))
				{
					continue;
				}
				int num = (from rend in ((Component)item7).GetComponentsInChildren<MeshFilter>()
					where Object.op_Implicit((Object)(object)rend) && ((Component)rend).gameObject.activeSelf && ((Component)rend).gameObject.activeInHierarchy && Object.op_Implicit((Object)(object)rend.mesh) && rend.mesh.subMeshCount > 0 && Object.op_Implicit((Object)(object)((Component)rend).GetComponent<MeshRenderer>()) && ((Renderer)((Component)rend).GetComponent<MeshRenderer>()).enabled
					select rend).Sum((MeshFilter rend) => rend.mesh.subMeshCount) + (from rend in ((Component)item7).GetComponentsInChildren<SkinnedMeshRenderer>()
					where Object.op_Implicit((Object)(object)rend) && ((Component)rend).gameObject.activeSelf && Object.op_Implicit((Object)(object)rend.sharedMesh) && rend.sharedMesh.subMeshCount > 0 && ((Renderer)rend).enabled
					select rend).Sum((SkinnedMeshRenderer rend) => rend.sharedMesh.subMeshCount);
				if (num > 0)
				{
					float item = 1f / (float)num;
					List<float> list8 = new List<float>();
					for (int k = 0; k < num - 1; k++)
					{
						list8.Add(item);
					}
					((CharacterItem)item7).SubmeshArea = list8.ToArray();
				}
			}
			foreach (WeaponItem item8 in from x in hiddenUnits.LoadAllAssets<GameObject>()
				where Object.op_Implicit((Object)(object)x.GetComponent<WeaponItem>())
				select x.GetComponent<WeaponItem>())
			{
				if (!Object.op_Implicit((Object)(object)item8))
				{
					continue;
				}
				int num2 = (from rend in ((Component)item8).GetComponentsInChildren<MeshFilter>()
					where Object.op_Implicit((Object)(object)rend) && ((Component)rend).gameObject.activeSelf && ((Component)rend).gameObject.activeInHierarchy && Object.op_Implicit((Object)(object)rend.mesh) && rend.mesh.subMeshCount > 0 && Object.op_Implicit((Object)(object)((Component)rend).GetComponent<MeshRenderer>()) && ((Renderer)((Component)rend).GetComponent<MeshRenderer>()).enabled
					select rend).Sum((MeshFilter rend) => rend.mesh.subMeshCount) + (from rend in ((Component)item8).GetComponentsInChildren<SkinnedMeshRenderer>()
					where Object.op_Implicit((Object)(object)rend) && ((Component)rend).gameObject.activeSelf && Object.op_Implicit((Object)(object)rend.sharedMesh) && rend.sharedMesh.subMeshCount > 0 && ((Renderer)rend).enabled
					select rend).Sum((SkinnedMeshRenderer rend) => rend.sharedMesh.subMeshCount);
				if (num2 > 0)
				{
					float item2 = 1f / (float)num2;
					List<float> list9 = new List<float>();
					for (int l = 0; l < num2 - 1; l++)
					{
						list9.Add(item2);
					}
					((CharacterItem)item8).SubmeshArea = list9.ToArray();
				}
			}
			AudioSource[] array5 = hiddenUnits.LoadAllAssets<AudioSource>();
			for (int j = 0; j < array5.Length; j++)
			{
				array5[j].outputAudioMixerGroup = ServiceLocator.GetService<GameModeService>().AudioSettings.AudioMixer.outputAudioMixerGroup;
			}
			TGAddons.AddItems((IEnumerable<UnitBlueprint>)hiddenUnits.LoadAllAssets<UnitBlueprint>(), (IEnumerable<Faction>)hiddenUnits.LoadAllAssets<Faction>(), (IEnumerable<TABSCampaignAsset>)hiddenUnits.LoadAllAssets<TABSCampaignAsset>(), (IEnumerable<TABSCampaignLevelAsset>)hiddenUnits.LoadAllAssets<TABSCampaignLevelAsset>(), (IEnumerable<VoiceBundle>)hiddenUnits.LoadAllAssets<VoiceBundle>(), (IEnumerable<FactionIcon>)hiddenUnits.LoadAllAssets<FactionIcon>(), from x in hiddenUnits.LoadAllAssets<GameObject>()
				select x.GetComponent<Unit>(), from x in hiddenUnits.LoadAllAssets<GameObject>()
				select x.GetComponent<PropItem>(), from x in hiddenUnits.LoadAllAssets<GameObject>()
				select x.GetComponent<SpecialAbility>(), from x in hiddenUnits.LoadAllAssets<GameObject>()
				select x.GetComponent<WeaponItem>(), from x in hiddenUnits.LoadAllAssets<GameObject>()
				select x.GetComponent<ProjectileEntity>());
			TGMain.newSounds.AddRange(hiddenUnits.LoadAllAssets<SoundBank>());
		}
	}
	public class MapCringe : GameStateListener
	{
		private GameObject MyClone;

		public override void OnEnterBattleState()
		{
		}

		public override void OnEnterPlacementState()
		{
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			((Component)this).gameObject.SetActive(false);
			if (Object.op_Implicit((Object)(object)MyClone))
			{
				Object.Destroy((Object)(object)MyClone);
			}
			MyClone = Object.Instantiate<GameObject>(((Component)this).gameObject, ((Component)this).transform.position, ((Component)this).transform.rotation, ((Component)this).transform.parent);
			MyClone.SetActive(true);
			Object.Destroy((Object)(object)MyClone.GetComponent<MapCringe>());
		}
	}
	public class MeleeWeaponLightning : CollisionWeaponEffect
	{
		private Unit Target;

		private Unit OldTarget;

		private Unit OwnUnit;

		private List<Unit> HitList = new List<Unit>();

		public float maxTargetRange = 6f;

		public int chainCount = 20;

		public float damage = 1000f;

		public GameObject lineObject;

		public int consecutiveChains = 1;

		private void Start()
		{
			OwnUnit = ((Component)this).GetComponent<Weapon>().connectedData.unit;
		}

		public override void DoEffect(Transform hitTransform, Collision collision)
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)((Component)hitTransform.root).GetComponent<Unit>()) && ((Component)hitTransform.root).GetComponent<Unit>().Team != OwnUnit.Team && !((Component)hitTransform.root).GetComponent<Unit>().data.Dead)
			{
				OldTarget = ((Component)hitTransform.root).GetComponent<Unit>();
				HitList.Add(OldTarget);
				((Damagable)OldTarget.data.healthHandler).TakeDamage(damage, Vector3.zero, (Unit)null, (DamageType)0);
				SetTarget(((Component)this).transform.position);
				((MonoBehaviour)this).StartCoroutine(DoLightning());
			}
		}

		public IEnumerator DoLightning()
		{
			for (int i = 0; i < chainCount; i++)
			{
				for (int j = 0; j < consecutiveChains; j++)
				{
					if (Object.op_Implicit((Object)(object)Target) && Object.op_Implicit((Object)(object)Target.data) && Object.op_Implicit((Object)(object)Target.data.healthHandler) && Object.op_Implicit((Object)(object)lineObject) && Object.op_Implicit((Object)(object)OldTarget))
					{
						GameObject obj = Object.Instantiate<GameObject>(lineObject, ((Component)OldTarget).transform, true);
						TransformExtensions.FindChildRecursive(obj.transform, "T1").position = OldTarget.data.mainRig.position;
						TransformExtensions.FindChildRecursive(obj.transform, "T2").position = Target.data.mainRig.position;
						((Damagable)Target.data.healthHandler).TakeDamage(damage, Vector3.zero, (Unit)null, (DamageType)0);
						HitList.Add(Target);
						OldTarget = Target;
					}
					if (Object.op_Implicit((Object)(object)OldTarget))
					{
						SetTarget(OldTarget.data.mainRig.position);
					}
				}
				yield return (object)new WaitForSeconds(0.1f);
			}
			HitList.Clear();
		}

		public void SetTarget(Vector3 source)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			Target = null;
			Unit[] array = (from hit in Physics.SphereCastAll(((Component)this).transform.position, maxTargetRange, Vector3.up, 0.1f, LayerMask.GetMask(new string[1] { "MainRig" }))
				select ((Component)((RaycastHit)(ref hit)).transform.root).GetComponent<Unit>() into x
				where Object.op_Implicit((Object)(object)x) && !x.data.Dead && x.Team != OwnUnit.Team && !HitList.Contains(x)
				select x).OrderBy(delegate(Unit x)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				Vector3 val = ((Component)x.data.mainRig).transform.position - source;
				return ((Vector3)(ref val)).magnitude;
			}).Distinct().ToArray();
			if (array.Length != 0)
			{
				Target = array[0];
			}
		}
	}
	public class MeleeWeaponSteal : CollisionWeaponEffect
	{
		public override void DoEffect(Transform hitTransform, Collision collision)
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d9: Expected O, but got Unknown
			//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)((Component)hitTransform).GetComponent<Rigidbody>()) || !Object.op_Implicit((Object)(object)((Component)hitTransform.root).GetComponent<Unit>()) || ((Component)hitTransform.root).GetComponent<Unit>().Team == ((Component)this).GetComponent<Weapon>().connectedData.unit.Team || ((Component)hitTransform.root).GetComponent<Unit>().data.Dead)
			{
				return;
			}
			GameObject val = null;
			HandType val2 = (HandType)0;
			Unit component = ((Component)hitTransform.root).GetComponent<Unit>();
			if (component.data.health > 600f || component.data.Dead)
			{
				return;
			}
			HoldingHandler componentInChildren = ((Component)component).GetComponentInChildren<HoldingHandler>();
			if (Object.op_Implicit((Object)(object)componentInChildren))
			{
				((Component)component).GetComponentInChildren<WeaponHandler>().fistRefernce = null;
				if (Object.op_Implicit((Object)(object)componentInChildren.rightObject))
				{
					val = ((Component)componentInChildren.rightObject).gameObject;
					val2 = (HandType)0;
					componentInChildren.LetGoOfWeapon(val);
					Object.Destroy((Object)(object)componentInChildren.rightObject);
				}
				else if (Object.op_Implicit((Object)(object)componentInChildren.leftObject))
				{
					val = ((Component)componentInChildren.leftObject).gameObject;
					val2 = (HandType)1;
					componentInChildren.LetGoOfWeapon(val);
					Object.Destroy((Object)(object)componentInChildren.leftObject);
				}
			}
			if (!((Object)(object)val != (Object)null))
			{
				return;
			}
			val.transform.SetParent((Transform)null);
			if (!Object.op_Implicit((Object)(object)((Component)((Component)this).transform.root).GetComponentInChildren<HoldingHandler>()))
			{
				return;
			}
			((Component)((Component)this).transform.root).GetComponentInChildren<HoldingHandler>().LetGoOfWeapon(((Component)this).gameObject);
			((Component)this).gameObject.AddComponent<RemoveAfterSeconds>().shrink = true;
			Weapon val3 = ((Component)((Component)this).transform.root).GetComponent<Unit>().unitBlueprint.SetWeapon(((Component)((Component)this).transform.root).GetComponent<Unit>(), ((Component)((Component)this).transform.root).GetComponent<Unit>().Team, val, new PropItemData(), val2, ((Component)((Component)this).transform.root).GetComponent<Unit>().data.mainRig.rotation, new List<GameObject>(), false);
			((Component)((Component)this).transform.root).GetComponentInChildren<HoldingHandler>().leftHandActivity = componentInChildren.leftHandActivity;
			if (Object.op_Implicit((Object)(object)((Component)val3).GetComponent<ConfigurableJoint>()))
			{
				ConfigurableJoint[] componentsInChildren = ((Component)val3).GetComponentsInChildren<ConfigurableJoint>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					Object.Destroy((Object)(object)componentsInChildren[i]);
				}
			}
			Object.Destroy((Object)(object)val);
		}
	}
	public class MoveTransformCross : MonoBehaviour
	{
		private float Counter;

		private Transform Target;

		private Vector3 TrackedPosition;

		public bool updatePosition;

		public MoveTransform projectile;

		public DelayEvent delayEvent;

		public AnimationCurve rotationSpeedOverTime;

		[Header("Movement")]
		public float force = 1f;

		public float rotationForce = 1f;

		public float drag = 0.9f;

		[Header("Return")]
		public float returnThreshold = 0.2f;

		public float returnDelay = 2f;

		private void Start()
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			TeamHolder component = ((Component)this).GetComponent<TeamHolder>();
			if (Object.op_Implicit((Object)(object)component) && Object.op_Implicit((Object)(object)component.spawnerWeapon))
			{
				Target = component.spawnerWeapon.transform;
			}
			else
			{
				TrackedPosition = ((Component)this).transform.position;
			}
		}

		private void Update()
		{
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			Counter += Time.deltaTime;
			if (updatePosition && (Object)(object)Target != (Object)null)
			{
				TrackedPosition = ((Component)Target).transform.position;
			}
			Vector3 val = TrackedPosition - ((Component)this).transform.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			normalized.y = 0f;
			Quaternion val2 = Quaternion.LookRotation(normalized);
			((Component)this).transform.rotation = Quaternion.RotateTowards(((Component)this).transform.rotation, val2, rotationSpeedOverTime.Evaluate(Counter) * rotationForce * Time.deltaTime);
			MoveTransform obj = projectile;
			obj.velocity += ((Component)this).transform.forward * (force * Time.deltaTime);
			MoveTransform obj2 = projectile;
			obj2.velocity -= projectile.velocity * (drag * Time.deltaTime);
			if (Counter > returnDelay && Vector3.Distance(((Component)this).transform.position, TrackedPosition) < returnThreshold)
			{
				if ((Object)(object)Target != (Object)null)
				{
					((Component)Target).GetComponent<DelayEvent>().Go();
				}
				delayEvent.Go();
			}
		}
	}
	public class OdinShield : ProjectileSurfaceEffect
	{
		private enum ShieldStates
		{
			ReflectionRune,
			Deactivated
		}

		private ShieldStates ShieldState;

		private float Counter;

		private float Health;

		public float rechargeTime = 6f;

		public UnityEvent activateEvent = new UnityEvent();

		public UnityEvent deactivateEvent = new UnityEvent();

		public UnityEvent reflectEvent = new UnityEvent();

		public float maxHealth = 1500f;

		public void Start()
		{
			Health = maxHealth;
		}

		public void ReflectionRune()
		{
			ShieldState = ShieldStates.ReflectionRune;
			activateEvent.Invoke();
		}

		public void Deactivate()
		{
			ShieldState = ShieldStates.Deactivated;
			deactivateEvent.Invoke();
		}

		public override bool DoEffect(HitData hit, GameObject projectile)
		{
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			if (ShieldState != 0)
			{
				return false;
			}
			if (Object.op_Implicit((Object)(object)projectile.GetComponent<ProjectileHit>()))
			{
				Health -= projectile.GetComponent<ProjectileHit>().damage;
			}
			if (Object.op_Implicit((Object)(object)projectile.GetComponent<CollisionWeapon>()))
			{
				Health -= projectile.GetComponent<CollisionWeapon>().damage;
			}
			if (Health <= 0f)
			{
				Counter = 0f;
				Deactivate();
				return false;
			}
			if (Object.op_Implicit((Object)(object)projectile.GetComponent<TeamHolder>()))
			{
				projectile.GetComponent<TeamHolder>().SwitchTeam();
				projectile.GetComponent<TeamHolder>().spawner = null;
			}
			MoveTransform component = projectile.GetComponent<MoveTransform>();
			component.velocity *= -1f;
			projectile.GetComponent<RaycastTrail>().ignoredFrames = 2;
			reflectEvent.Invoke();
			return true;
		}

		public void Update()
		{
			Counter += Time.deltaTime;
			if (Counter > rechargeTime && Health <= 0f)
			{
				Health = maxHealth;
				ReflectionRune();
			}
		}
	}
	public class ProjectileHitScale : ProjectileHitEffect
	{
		public class Scaling : MonoBehaviour
		{
		}

		private int ScaleCount;

		public float scaleDelay = 0.5f;

		public int scaleLimit = 1;

		public AnimationCurve scaleCurve;

		public float scaleCurveMultiplier = 1f;

		public UnityEvent scaleEvent = new UnityEvent();

		private void Awake()
		{
			if (HUMain.InfiniteScalingEnabled)
			{
				scaleLimit = 9999;
			}
		}

		public override bool DoEffect(HitData hit)
		{
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			if (!Object.op_Implicit((Object)(object)hit.rigidbody) || !Object.op_Implicit((Object)(object)((Component)hit.transform.root).GetComponent<Unit>()) || (Object.op_Implicit((Object)(object)((Component)hit.transform.root).GetComponent<Unit>()) && ((Component)hit.transform.root).GetComponent<Unit>().data.Dead) || (Object.op_Implicit((Object)(object)((Component)hit.transform.root).GetComponent<Unit>()) && ((Component)hit.transform.root).GetComponent<Unit>().Team == ((Component)this).GetComponent<TeamHolder>().team) || Object.op_Implicit((Object)(object)((Component)hit.transform).GetComponent<Scaling>()))
			{
				return false;
			}
			((MonoBehaviour)this).StartCoroutine(DoScaling(hit));
			return true;
		}

		private IEnumerator DoScaling(HitData hit)
		{
			((Component)hit.transform).gameObject.AddComponent<Scaling>();
			yield return (object)new WaitForSeconds(scaleDelay);
			scaleEvent.Invoke();
			float t = 0f;
			Vector3 originalVector = hit.transform.localScale;
			while (t < ((Keyframe)(ref scaleCurve.keys[scaleCurve.keys.Length - 1])).time)
			{
				Vector3 localScale = hit.transform.localScale;
				if (!(((Vector3)(ref localScale)).magnitude > 0.1f))
				{
					break;
				}
				hit.transform.localScale = originalVector * (scaleCurve.Evaluate(t) * scaleCurveMultiplier);
				t += Time.deltaTime;
				yield return null;
			}
			ScaleCount++;
			if (ScaleCount >= scaleLimit)
			{
				Object.Destroy((Object)(object)((Component)hit.transform).GetComponent<Scaling>());
			}
		}
	}
	public class RootBehavior : MonoBehaviour
	{
		private float Counter;

		private Unit UnitTarget;

		private FixedJoint Joint;

		private TeamHolder Team;

		[Header("Root Settings")]
		public List<Rigidbody> rigs = new List<Rigidbody>();

		public Transform moveTarget;

		public Transform tip;

		public float targetRange = 3f;

		public float followSpeed = 1f;

		[Header("Joint Settings")]
		public float adjustTime = 1f;

		public float attachDistance = 1f;

		public float breakForce = 100000f;

		public bool lerpToCenterOfTip;

		[Header("Damage Settings")]
		public UnityEvent hitEvent = new UnityEvent();

		public float damage = 20f;

		public bool doConstantDamage;

		private void Start()
		{
			Team = ((Component)this).GetComponent<TeamHolder>();
		}

		private void Update()
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			Counter += Time.deltaTime;
			if (Object.op_Implicit((Object)(object)UnitTarget) && !Object.op_Implicit((Object)(object)Joint) && Vector3.Distance(tip.position, UnitTarget.data.mainRig.position) < attachDistance && ((Component)UnitTarget.data.mainRig).GetComponents<ConfigurableJoint>().Length < 3)
			{
				((MonoBehaviour)this).StartCoroutine(AttachJoint());
			}
			else if (Object.op_Implicit((Object)(object)UnitTarget) && Object.op_Implicit((Object)(object)Joint) && doConstantDamage)
			{
				((Damagable)UnitTarget.data.healthHandler).TakeDamage(damage * Time.deltaTime, Vector3.zero, (Unit)null, (DamageType)0);
			}
		}

		public void DoRooting()
		{
			((MonoBehaviour)this).StartCoroutine(ChooseTarget());
		}

		private IEnumerator ChooseTarget()
		{
			SetTarget();
			if (Object.op_Implicit((Object)(object)UnitTarget))
			{
				float t = 0f;
				Vector3 beginPosition = moveTarget.position;
				while (t < 1f && !Object.op_Implicit((Object)(object)Joint) && Object.op_Implicit((Object)(object)UnitTarget))
				{
					t += Time.deltaTime * followSpeed;
					moveTarget.position = Vector3.Lerp(beginPosition, UnitTarget.data.mainRig.position, Mathf.Clamp(t, 0f, 1f));
					yield return null;
				}
			}
		}

		public IEnumerator AttachJoint()
		{
			if (!Object.op_Implicit((Object)(object)UnitTarget))
			{
				yield break;
			}
			foreach (Rigidbody rig in rigs)
			{
				rig.isKinematic = false;
			}
			((Behaviour)((Component)this).GetComponent<CCDIK>()).enabled = false;
			Joint = ((Component)UnitTarget.data.mainRig).gameObject.AddComponent<FixedJoint>();
			((Joint)Joint).connectedBody = ((Component)tip).GetComponent<Rigidbody>();
			((Joint)Joint).breakForce = breakForce;
			((Joint)Joint).breakTorque = breakForce;
			if (lerpToCenterOfTip)
			{
				((MonoBehaviour)this).StartCoroutine(LerpJoint());
			}
			if (!doConstantDamage)
			{
				((Damagable)UnitTarget.data.healthHandler).TakeDamage(damage, Vector3.zero, (Unit)null, (DamageType)0);
			}
			hitEvent.Invoke();
			RemoveAfterSeconds seconds = ((Component)this).GetComponent<RemoveAfterSeconds>();
			yield return (object)new WaitUntil((Func<bool>)(() => Counter >= seconds.seconds - 1f));
			if (Object.op_Implicit((Object)(object)Joint))
			{
				Object.Destroy((Object)(object)Joint);
			}
		}

		public IEnumerator LerpJoint()
		{
			if (Object.op_Implicit((Object)(object)Joint))
			{
				float t = 0f;
				Vector3 initialVector = ((Joint)Joint).connectedAnchor;
				while (t < 1f && Object.op_Implicit((Object)(object)Joint))
				{
					((Joint)Joint).autoConfigureConnectedAnchor = false;
					t += Time.deltaTime * adjustTime;
					((Joint)Joint).connectedAnchor = Vector3.Lerp(initialVector, Vector3.zero, Mathf.Clamp(t, 0f, 1f));
					yield return null;
				}
			}
		}

		public void SetTarget()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			Unit[] array = (from hit in Physics.SphereCastAll(((Component)this).transform.position, targetRange, Vector3.up, 0.1f, LayerMask.GetMask(new string[1] { "MainRig" }))
				select ((Component)((RaycastHit)(ref hit)).transform.root).GetComponent<Unit>() into x
				where Object.op_Implicit((Object)(object)x) && !x.data.Dead && x.Team != Team.team
				select x).OrderBy(delegate(Unit x)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				Vector3 val = ((Component)x.data.mainRig).transform.position - ((Component)this).transform.position;
				return ((Vector3)(ref val)).magnitude;
			}).Distinct().ToArray();
			if (array.Length != 0)
			{
				UnitTarget = array[0];
			}
		}
	}
	public class SecretUnlockMultiple : GameStateListener
	{
		public string secretKey;

		public List<string> secretDescriptions = new List<string>();

		public Sprite secretIcon;

		public float distanceToUnlock = 5f;

		private RotationShake MRotationShake;

		private Rigidbody MSecretObject;

		private float MLookValue;

		private float MUnlockValue;

		public AudioClip hitClip;

		private AudioSource LoopSource;

		private Transform MMainCamTransform;

		public UnityEvent unlockEvent;

		public UnityEvent hideEvent;

		private bool Done;

		public Color glowColor;

		public GameObject unlockSparkEffect;

		protected override void Awake()
		{
			((GameStateListener)this).Awake();
			if ((Object)(object)MMainCamTransform == (Object)null)
			{
				((GameStateListener)this).OnEnterNewScene();
			}
		}

		private void Update()
		{
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0118: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)MMainCamTransform != (Object)null) || !Object.op_Implicit((Object)(object)MSecretObject) || Done)
			{
				return;
			}
			LoopSource.volume = ((MUnlockValue <= 0f) ? 0f : Mathf.Pow(MUnlockValue * 0.25f, 1.3f));
			if (float.IsNaN(LoopSource.volume))
			{
				LoopSource.volume = 0f;
			}
			float num = 1f + 1f * MUnlockValue;
			LoopSource.pitch = ((num >= 0f) ? num : 0f);
			if (MUnlockValue > 0f || MLookValue > 10f)
			{
				SetColor();
			}
			float num2 = Vector3.Distance(MSecretObject.worldCenterOfMass, MMainCamTransform.position);
			if (num2 > distanceToUnlock)
			{
				MUnlockValue -= Time.unscaledDeltaTime * 0.2f;
				return;
			}
			float num3 = Vector3.Angle(MMainCamTransform.forward, MSecretObject.worldCenterOfMass - MMainCamTransform.position);
			MLookValue = 1000f / (num2 * num3);
			if (MLookValue > 8f)
			{
				float num4 = 0.2f;
				MUnlockValue += num4 * Time.unscaledDeltaTime;
				UnlockProgressFeedback();
				if (MUnlockValue > 1f)
				{
					((MonoBehaviour)this).StartCoroutine(UnlockSecret());
				}
			}
			else
			{
				MUnlockValue -= Time.unscaledDeltaTime * 0.2f;
			}
		}

		private void UnlockProgressFeedback()
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)MRotationShake))
			{
				if (MUnlockValue <= 0f)
				{
					MRotationShake.AddForce(Random.onUnitSphere * 2f);
					MUnlockValue = 0f;
				}
				((Behaviour)MRotationShake).enabled = true;
				MRotationShake.AddForce(Random.onUnitSphere * MUnlockValue * Time.deltaTime * 50f);
			}
		}

		private void SetColor()
		{
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			MUnlockValue = Mathf.Clamp(MUnlockValue, 0f, float.PositiveInfinity);
			Renderer[] componentsInChildren = ((Component)MSecretObject).GetComponentsInChildren<Renderer>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				Material[] materials = componentsInChildren[i].materials;
				for (int j = 0; j < materials.Length; j++)
				{
					if (materials[j].HasProperty("_EmissionColor"))
					{
						materials[j].EnableKeyword("_EMISSION");
						materials[j].SetColor("_EmissionColor", glowColor * MUnlockValue * 2f);
					}
				}
				componentsInChildren[i].materials = materials;
			}
		}

		private IEnumerator UnlockSecret()
		{
			if (!((Behaviour)this).enabled || string.IsNullOrWhiteSpace(secretKey))
			{
				yield break;
			}
			if (Object.op_Implicit((Object)(object)ScreenShake.Instance))
			{
				ScreenShake.Instance.AddForce(Vector3.up * 8f, ((Component)MSecretObject).transform.position);
			}
			if (Object.op_Implicit((Object)(object)unlockSparkEffect))
			{
				GameObject val = Object.Instantiate<GameObject>(unlockSparkEffect, ((Component)MSecretObject).transform.position, ((Component)MSecretObject).transform.rotation);
				val.AddComponent<RemoveAfterSeconds>().seconds = 5f;
				MeshRenderer componentInChildren = ((Component)MSecretObject).GetComponentInChildren<MeshRenderer>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					ShapeModule shape = val.GetComponent<ParticleSystem>().shape;
					((ShapeModule)(ref shape)).meshRenderer = componentInChildren;
				}
			}
			((Component)MSecretObject).gameObject.SetActive(false);
			UnityEvent obj = unlockEvent;
			if (obj != null)
			{
				obj.Invoke();
			}
			LoopSource.Stop();
			LoopSource.volume = 1f;
			LoopSource.PlayOneShot(hitClip);
			Done = true;
			ServiceLocator.GetService<ISaveLoaderService>().UnlockSecret(secretKey);
			for (int i = 0; i < secretDescriptions.Count; i++)
			{
				ServiceLocator.GetService<ModalPanel>().OpenUnlockPanel(secretDescriptions[i], secretIcon);
				yield return (object)new WaitForSeconds(0.1f);
			}
		}

		public override void OnEnterNewScene()
		{
			((GameStateListener)this).OnEnterNewScene();
			LoopSource = ((Component)this).GetComponent<AudioSource>();
			if (Object.op_Implicit((Object)(object)LoopSource))
			{
				LoopSource.volume = 0f;
			}
			MRotationShake = ((Component)this).GetComponentInChildren<RotationShake>();
			MSecretObject = ((Component)this).GetComponentInChildren<Rigidbody>();
			if (Object.op_Implicit((Object)(object)MSecretObject))
			{
				MSecretObject.isKinematic = true;
			}
			if (!string.IsNullOrWhiteSpace(secretKey) && ServiceLocator.GetService<ISaveLoaderService>().HasUnlockedSecret(secretKey))
			{
				if (Object.op_Implicit((Object)(object)MSecretObject))
				{
					((Component)MSecretObject).gameObject.SetActive(false);
				}
				((Behaviour)this).enabled = false;
				UnityEvent obj = hideEvent;
				if (obj != null)
				{
					obj.Invoke();
				}
			}
			PlayerCamerasManager service = ServiceLocator.GetService<PlayerCamerasManager>();
			MainCam val = ((service != null) ? service.GetMainCam((Player)0) : null);
			MMainCamTransform = (((Object)(object)val != (Object)null) ? ((Component)val).transform : null);
		}

		public override void OnEnterPlacementState()
		{
		}

		public override void OnEnterBattleState()
		{
		}

		public static void CheckAchievements()
		{
			AchievementService service = ServiceLocator.GetService<AchievementService>();
			ISaveLoaderService secretService = ServiceLocator.GetService<ISaveLoaderService>();
			if (HasUnlockedFaction(874593522))
			{
				service.UnlockAchievement("UNLOCKED_ALL_SECRET");
			}
			if (HasUnlockedFaction(673578412))
			{
				service.UnlockAchievement("UNLOCKED_ALL_LEGACY");
			}
			bool HasUnlockedFaction(int factionId)
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				UnitBlueprint[] units = LandfallUnitDatabase.GetDatabase().GetFactionByGUID(new DatabaseID(-1, factionId)).Units;
				for (int i = 0; i < units.Length; i++)
				{
					string unlockKey = units[i].Entity.UnlockKey;
					if (!string.IsNullOrEmpty(unlockKey) && !secretService.HasUnlockedSecret(unlockKey))
					{
						return false;
					}
				}
				return true;
			}
		}
	}
	public class ShrinkParent : MonoBehaviour
	{
		private float Counter;

		private bool Scaling;

		public float scaler = 0.5f;

		public void Shrink()
		{
			Scaling = true;
		}

		private void Update()
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			Counter += Time.deltaTime;
			if (Scaling && Counter < 1f)
			{
				Transform parent = ((Component)this).transform.parent;
				parent.localScale -= Vector3.one * (scaler * Time.deltaTime);
			}
		}
	}
	public class ShurikenRing : MonoBehaviour
	{
		[Serializable]
		public class Shuriken
		{
			public GameObject obj;

			public MoveTransform move;

			public RaycastTrail trail;

			public DelayEvent delay;

			public float sinceSpawn;

			public float sinceFired;
		}

		private ShootPosition[] SwordPoints;

		private readonly List<Shuriken> Shurikens = new List<Shuriken>();

		private DataHandler Data;

		private bool Done;

		private float Counter;

		private float AttackSpeedMulti = 1f;

		private int AttackID;

		public GameObject sourceShuriken;

		public float followSpeed = 1f;

		public float startDelay = 1f;

		[Header("Attack")]
		public int shurikensPerAttack = 3;

		public float attackRate = 0.5f;

		public float attackRatePerShuriken = 0.5f;

		public float attackDistance = 15f;

		public UnityEvent attackEvent;

		public float spread = 10f;

		private void Awake()
		{
			SwordPoints = ((Component)this).GetComponentsInChildren<ShootPosition>();
		}

		private void Start()
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			Data = ((Component)((Component)this).transform.root).GetComponentInChildren<DataHandler>();
			List<Renderer> list = new List<Renderer>();
			ShootPosition[] swordPoints = SwordPoints;
			foreach (ShootPosition val in swordPoints)
			{
				Shuriken shuriken = CreateNewSword(((Component)val).transform.position + Vector3.up * 2f, ((Component)val).transform.rotation, val);
				Renderer[] componentsInChildren = shuriken.obj.GetComponentsInChildren<Renderer>();
				if (componentsInChildren != null && componentsInChildren.Length != 0)
				{
					list.AddRange(componentsInChildren);
				}
				Shurikens.Add(shuriken);
			}
			if ((Object)(object)Data != (Object)null && (Object)(object)Data.unit != (Object)null)
			{
				Data.unit.AddRenderersToShowHide(list.ToArray(), Data.unit.IsSpawnedInBlindPlacement);
			}
		}

		private void Update()
		{
			//IL_026d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0280: Unknown result type (might be due to invalid IL or missing references)
			//IL_029c: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0112: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			if (Done)
			{
				return;
			}
			if (Object.op_Implicit((Object)(object)Data) && Data.Dead)
			{
				Done = true;
				for (int i = 0; i < Shurikens.Count; i++)
				{
					AttackID = i;
					Attack(Data.mainRig, AttackID);
				}
			}
			if (Object.op_Implicit((Object)(object)Data.weaponHandler))
			{
				AttackSpeedMulti = Data.weaponHandler.attackSpeedMultiplier;
			}
			bool num = (Object)(object)Data.unit == (Object)null || !Data.unit.IsRemotelyControlled;
			Counter += Time.deltaTime * AttackSpeedMulti;
			if (num && Object.op_Implicit((Object)(object)Data.targetMainRig) && Counter > attackRate)
			{
				for (int j = 0; j < shurikensPerAttack; j++)
				{
					float num2 = 999f;
					for (int k = 0; k < SwordPoints.Length; k++)
					{
						float num3 = Vector3.Angle(Data.targetMainRig.position - ((Component)this).transform.position, ((Component)SwordPoints[k]).gameObject.transform.position - ((Component)this).transform.position);
						if (num3 < num2 && Shurikens[k].sinceSpawn > startDelay && Shurikens[k].sinceFired > attackRatePerShuriken)
						{
							num2 = num3;
							AttackID = k;
						}
					}
					if (Object.op_Implicit((Object)(object)Data.targetMainRig) && Data.distanceToTarget < attackDistance)
					{
						Attack(Data.targetMainRig, AttackID);
					}
				}
			}
			for (int l = 0; l < Shurikens.Count; l++)
			{
				if ((Object)(object)Shurikens[l].obj != (Object)null)
				{
					Shurikens[l].sinceSpawn += Time.deltaTime;
					Shurikens[l].sinceFired += Time.deltaTime;
					Transform transform = Shurikens[l].obj.transform;
					transform.position += (((Component)SwordPoints[l]).transform.position - Shurikens[l].obj.transform.position) * (followSpeed * Time.deltaTime);
					Shurikens[l].obj.transform.rotation = ((Component)SwordPoints[l]).transform.rotation;
				}
			}
		}

		public void Attack(Rigidbody target, int useAttackID)
		{
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			Counter = 0f;
			if (useAttackID < 0 || useAttackID >= Shurikens.Count)
			{
				useAttackID = Random.Range(0, Shurikens.Count);
			}
			Shuriken shuriken = Shurikens[useAttackID];
			if (shuriken != null)
			{
				shuriken.sinceFired = 0f;
				((MonoBehaviour)this).StartCoroutine(DoAttack(shuriken, target));
				attackEvent.Invoke();
				if (!Done)
				{
					Shurikens[useAttackID] = CreateNewSword(((Component)SwordPoints[useAttackID]).gameObject.transform.position, ((Component)SwordPoints[useAttackID]).gameObject.transform.rotation, SwordPoints[useAttackID]);
				}
			}
		}

		private void OnDestroy()
		{
			((MonoBehaviour)this).StopAllCoroutines();
			foreach (Shuriken shuriken in Shurikens)
			{
				Object.Destroy((Object)(object)shuriken.obj);
			}
		}

		private IEnumerator DoAttack(Shuriken attackShuriken, Rigidbody target)
		{
			if (Object.op_Implicit((Object)(object)attackShuriken.obj))
			{
				Vector3 val = target.position - attackShuriken.obj.transform.position;
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				attackShuriken.obj.transform.rotation = Quaternion.LookRotation(normalized + 0.01f * spread * Random.insideUnitSphere);
				SetProjectileStats(attackShuriken, normalized, target, attackShuriken.obj.transform.forward, target.position, target.velocity);
				((Behaviour)attackShuriken.move).enabled = true;
				((Behaviour)attackShuriken.trail).enabled = true;
				((Behaviour)attackShuriken.delay).enabled = true;
				MoveTransformCross component = attackShuriken.obj.GetComponent<MoveTransformCross>();
				if (Object.op_Implicit((Object)(object)component))
				{
					((Behaviour)component).enabled = true;
				}
			}
			yield break;
		}

		private Shuriken CreateNewSword(Vector3 pos, Quaternion rot, ShootPosition point)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			Shuriken obj = new Shuriken
			{
				obj = Object.Instantiate<GameObject>(sourceShuriken, pos, rot)
			};
			obj.move = obj.obj.GetComponent<MoveTransform>();
			((Behaviour)obj.move).enabled = false;
			obj.trail = obj.obj.GetComponent<RaycastTrail>();
			((Behaviour)obj.trail).enabled = false;
			obj.delay = obj.obj.GetComponent<DelayEvent>();
			((Behaviour)obj.delay).enabled = false;
			MoveTransformCross component = obj.obj.GetComponent<MoveTransformCross>();
			if (Object.op_Implicit((Object)(object)component))
			{
				((Behaviour)component).enabled = false;
			}
			TeamHolder obj2 = GameObjectExtensions.FetchComponent<TeamHolder>(obj.obj);
			obj2.team = Data.team;
			obj2.spawner = ((Component)((Component)this).transform.root).gameObject;
			obj2.spawnerWeapon = ((Component)point).gameObject;
			obj.obj.GetComponentInChildren<CodeAnimation>().speedMultiplier = AttackSpeedMulti;
			return obj;
		}

		public void SetProjectileStats(Shuriken shuriken, Vector3 spawnDir, Rigidbody targetRig, Vector3 shootPositionForward, Vector3 targetRigPosition, Vector3 targetRigVelocity)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			Compensation componentInChildren = shuriken.obj.GetComponentInChildren<Compensation>();
			if (Object.op_Implicit((Object)(object)componentInChildren) && Object.op_Implicit((Object)(object)targetRig))
			{
				((Component)componentInChildren).transform.rotation = Quaternion.LookRotation(componentInChildren.GetCompensation(targetRigPosition, targetRigVelocity, 0f) + Random.insideUnitSphere * 0.01f);
			}
			if (Object.op_Implicit((Object)(object)componentInChildren) && componentInChildren.forwardCompensation > 0f && Object.op_Implicit((Object)(object)targetRig))
			{
				shuriken.move.selfImpulse.z += Mathf.Pow(Mathf.Clamp(Vector3.Distance(targetRigPosition, ((Component)this).transform.position), 0f, componentInChildren.clampDistance), componentInChildren.rangePow) * componentInChildren.forwardCompensation;
			}
		}
	}
	public class SwordAfterimages : MonoBehaviour
	{
		private float Counter;

		private Rigidbody Rig;

		public GameObject objectToSpawn;

		public bool requireCooldown;

		public bool requireThreshold;

		public float cooldown;

		public float thresholdToSpawn;

		public bool canSpawn;

		private void Start()
		{
			Rig = ((Component)this).GetComponentInParent<Rigidbody>();
		}

		private void Update()
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			Counter += Time.deltaTime;
			if (!canSpawn)
			{
				return;
			}
			if (requireThreshold)
			{
				Vector3 velocity = Rig.velocity;
				if (((Vector3)(ref velocity)).magnitude < thresholdToSpawn)
				{
					return;
				}
			}
			if (!requireCooldown || !(cooldown > Counter))
			{
				DoAfterimage();
			}
		}

		public void DoAfterimage()
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			Counter = 0f;
			Object.Instantiate<GameObject>(objectToSpawn, ((Component)this).transform.position, ((Component)this).transform.rotation);
		}

		public void CanSpawn()
		{
			canSpawn = true;
		}

		public void CannotSpawn()
		{
			canSpawn = false;
		}
	}
	public class TriggerChickenStickRoam : MonoBehaviour
	{
		public UnityEvent roamBeginEvent = new UnityEvent();

		public UnityEvent roamEndEvent = new UnityEvent();

		public void StartRoaming()
		{
			ChickenSticks[] componentsInChildren = ((Component)((Component)this).transform.root).GetComponentsInChildren<ChickenSticks>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				componentsInChildren[i].Roam();
			}
			((MonoBehaviour)this).StartCoroutine(OnStartRoaming());
		}

		private IEnumerator OnStartRoaming()
		{
			yield return (object)new WaitUntil((Func<bool>)(() => ((Component)((Component)this).transform.root).GetComponentsInChildren<ChickenSticks>().ToList().TrueForAll((ChickenSticks x) => x.currentState == ChickenSticks.ClubState.Roaming)));
			roamBeginEvent.Invoke();
			yield return (object)new WaitUntil((Func<bool>)(() => ((Component)((Component)this).transform.root).GetComponentsInChildren<ChickenSticks>().ToList().TrueForAll((ChickenSticks x) => x.currentState == ChickenSticks.ClubState.Idle)));
			roamEndEvent.Invoke();
		}
	}
	public class TriggerCollisionWeapon : MonoBehaviour
	{
		public float damage = 100f;

		public float knockback = 100f;

		public float minMassCap = 10f;

		public float cooldown;

		private float Counter;

		private bool CanDealDamage = true;

		public bool canDealDamageToTeammates;

		private bool StartedCounting;

		private CollisionWeaponEffect[] CollisionEffects;

		public UnityEvent collisionEvent;

		public MeleeWeapon meleeWeapon;

		public void Start()
		{
			CollisionEffects = ((Component)this).GetComponentsInChildren<CollisionWeaponEffect>();
			if ((Object)(object)meleeWeapon == (Object)null && Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeleeWeapon>()))
			{
				meleeWeapon = ((Component)this).GetComponent<MeleeWeapon>();
			}
		}

		public void Update()
		{
			if (StartedCounting)
			{
				Counter += Time.deltaTime;
			}
			if (Counter >= cooldown)
			{
				Counter = 0f;
				StartedCounting = false;
				CanDealDamage = true;
			}
		}

		public void OnTriggerStay(Collider col)
		{
			DoDamage(col);
		}

		public void OnTriggerEnter(Collider col)
		{
			DoDamage(col);
		}

		public void DoDamage(Collider col)
		{
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Expected O, but got Unknown
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)col.attachedRigidbody) && Object.op_Implicit((Object)(object)((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>()) && CanDealDamage && (((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>().Team != ((Component)((Component)this).transform.root).GetComponent<Unit>().Team || canDealDamageToTeammates) && !((Object)(object)((Component)col.attachedRigidbody).transform.root == (Object)(object)((Component)this).transform.root) && !(((Object)((Component)col.attachedRigidbody).transform.parent).name != "Rigidbodies") && (!Object.op_Implicit((Object)(object)meleeWeapon) || meleeWeapon.canDealDamage))
			{
				CollisionWeaponEffect[] collisionEffects = CollisionEffects;
				for (int i = 0; i < collisionEffects.Length; i++)
				{
					collisionEffects[i].DoEffect(((Component)col).transform, new Collision());
				}
				collisionEvent.Invoke();
				((Damagable)((Component)((Component)col.attachedRigidbody).transform.root).GetComponent<Unit>().data.healthHandler).TakeDamage(damage, Vector3.zero, ((Component)((Component)this).transform.root).GetComponent<Unit>(), (DamageType)1);
				AddForceToTarget(col.attachedRigidbody);
				if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<CollisionSound>()))
				{
					DoEffect(((Component)col).transform, col, 100f);
				}
				StartedCounting = true;
				CanDealDamage = false;
			}
		}

		public void AddForceToTarget(Rigidbody rig, float m = 1f)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			WilhelmPhysicsFunctions.AddForceWithMinWeight(rig, ((Component)this).transform.forward * knockback * m, (ForceMode)1, minMassCap);
			rig.velocity *= 0.7f;
		}

		public void DoEffect(Transform hitTransform, Collider col, float impact)
		{
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			if (!(impact * 0.5f < 0.1f) && (!((Component)this).GetComponent<CollisionSound>().onlySoundOnRig || Object.op_Implicit((Object)(object)col.attachedRigidbody)) && Object.op_Implicit((Object)(object)meleeWeapon))
			{
				ServiceLocator.GetService<SoundPlayer>().PlaySoundEffect(((Component)this).GetComponent<CollisionSound>().SoundEffectRef, impact * 0.5f, ((Component)this).transform.position, SoundEffectVariations.GetMaterialType(((Component)col).gameObject, col.attachedRigidbody), (Transform)null, 1f);
			}
		}
	}
}
namespace HiddenUnits.Properties
{
	[GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
	[DebuggerNonUserCode]
	[CompilerGenerated]
	internal class Resources
	{
		private static ResourceManager resourceMan;

		private static CultureInfo resourceCulture;

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static ResourceManager ResourceManager
		{
			get
			{
				if (resourceMan == null)
				{
					resourceMan = new ResourceManager("HiddenUnits.Properties.Resources", typeof(Resources).Assembly);
				}
				return resourceMan;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static CultureInfo Culture
		{
			get
			{
				return resourceCulture;
			}
			set
			{
				resourceCulture = value;
			}
		}

		internal static byte[] hiddenunits => (byte[])ResourceManager.GetObject("hiddenunits", resourceCulture);

		internal static byte[] humaps => (byte[])ResourceManager.GetObject("humaps", resourceCulture);

		internal static byte[] egyptmap => (byte[])ResourceManager.GetObject("egyptmap", resourceCulture);

		internal static byte[] egyptmap2 => (byte[])ResourceManager.GetObject("egyptmap2", resourceCulture);

		internal Resources()
		{
		}
	}
}
namespace HiddenUnits.HarmonyPatches
{
	[HarmonyPatch(typeof(ProjectileHit), "Hit")]
	internal class ArmorProjectilePatch
	{
		[HarmonyPrefix]
		public static bool Prefix(ProjectileHit __instance, RaycastHit sentHit, float multiplier, ref MoveTransform ___move, ref RaycastTrail ___trail, ref TeamHolder ___teamHolder)
		{
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			AchillesArmor.UnitIsArmored component = ((Component)((RaycastHit)(ref sentHit)).transform.root).GetComponent<AchillesArmor.UnitIsArmored>();
			if (!Object.op_Implicit((Object)(object)((Component)__instance).GetComponent<ProjectileHoming>()) && Object.op_Implicit((Object)(object)((RaycastHit)(ref sentHit)).transform) && Object.op_Implicit((Object)(object)component) && component.armorActive && Object.op_Implicit((Object)(object)((RaycastHit)(ref sentHit)).rigidbody) && component.blockPower > __instance.blockPoweredNeeded)
			{
				if (Object.op_Implicit((Object)(object)___move))
				{
					___move.velocity = Vector3.Reflect(___move.velocity, ((RaycastHit)(ref sentHit)).normal) * Random.Range(0.2f, 0.4f);
				}
				if (Object.op_Implicit((Object)(object)___trail))
				{
					___trail.ignoredFrames = 3;
				}
				Object.Instantiate<GameObject>(component.projectileHitEffect, ((RaycastHit)(ref sentHit)).point, Quaternion.identity);
				return false;
			}
			return true;
		}
	}
	[HarmonyPatch(typeof(CollisionWeapon), "OnCollisionEnter")]
	internal class ArmorWeaponPatch
	{
		[HarmonyPrefix]
		public static bool Prefix(CollisionWeapon __instance, Collision collision, ref MeleeWeapon ___meleeWeapon, ref Rigidbody ___rig, ref DataHandler ___connectedData)
		{
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			AchillesArmor.UnitIsArmored component = ((Component)collision.transform.root).GetComponent<AchillesArmor.UnitIsArmored>();
			if (Object.op_Implicit((Object)(object)collision.transform) && Object.op_Implicit((Object)(object)component) && component.armorActive && Object.op_Implicit((Object)(object)collision.rigidbody) && Object.op_Implicit((Object)(object)___rig) && Object.op_Implicit((Object)(object)___meleeWeapon) && ___meleeWeapon.isSwinging && Object.op_Implicit((Object)(object)___connectedData) && ((Component)component).GetComponent<Unit>().Team != ___connectedData.unit.Team && component.parryPower > ___meleeWeapon.requiredPowerToParry)
			{
				___meleeWeapon.StopSwing();
				Rigidbody obj = ___rig;
				Vector3 point = ((ContactPoint)(ref collision.contacts[0])).point;
				obj.AddForce(((Vector3)(ref point)).normalized * (0f - component.parryForce), (ForceMode)2);
				Object.Instantiate<GameObject>(component.weaponHitEffect, ((ContactPoint)(ref collision.contacts[0])).point, Quaternion.identity);
			}
			return true;
		}
	}
}
